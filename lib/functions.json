{
    "_caller": "**_caller()** Description: **version** of the program or session that invoked the currently running program; see [**[P] version**](https://www.stata.com/help.cgi?version) The current version at the time of this writing is 15.1, so 15.1 is the upper end of this range. If Stata 15.2 were the current version, 15.2 would be the upper end of this range, and likewise, if Stata 16 were the current version, 16 would be the upper end of this range. This is a function for use by programmers. Range: 1 to 15.1\n\n",
    "abbrev": "**abbrev(** _s_ , _n_ **)** Description: name _s_ , abbreviated to a length of _n_\n\nLength is measured in the number of display columns, not in the number of characters. For most users, the number of display columns equals the number of characters. For a detailed discussion of display columns, see **[U]** **12.4.2.2 Displaying Unicode characters**.\n\nIf any of the characters of _s_ are a period, \" **.** \", and _n_ < 8, then the value _n_ defaults to a value of 8. Otherwise, if _n_ < 5, then _n_ defaults to a value of 5. If _n_ is _missing_ , **abbrev()** will return the entire string _s_. **abbrev()** is typically used with variable names and variable names with factor-variable or time-series operators (the period case). **abbrev(\"displacement\",8)** is **displa~t**. Domain _s_ : strings Domain _n_ : integers 5 to 32 Range: strings\n\n",
    "abs": "**abs(** _x_ **)** Description: the absolute value of _x_ Domain: -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "acos": "**acos(** _x_ **)** Description: the radian value of the arccosine of _x_ Domain: -1 to 1 Range: 0 to pi\n\n",
    "acosh": "**acosh(** _x_ **)** Description: the inverse hyperbolic cosine of _x_ , **acosh(** _x_ **)** = ln{ _x_ +sqrt( _x_ * _x_ \\- 1)} Domain: 1 to 8.9e+307 Range: 0 to 709.77\n\n",
    "asin": "**asin(** _x_ **)** Description: the radian value of the arcsine of _x_ Domain: -1 to 1 Range: -pi/2 to pi/2\n\n",
    "asinh": "**asinh(** _x_ **)** Description: the inverse hyperbolic sine of _x_ , **asinh(** _x_ **)** = ln{ _x_ +sqrt( _x_ * _x_ \\+ 1)} Domain: -8.9e+307 to 8.9e+307 Range: -709.77 to 709.77\n\n",
    "atan": "**atan(** _x_ **)** Description: the radian value of the arctangent of _x_ Domain: -8e+307 to 8e+307 Range: -pi/2 to pi/2\n\n",
    "atan2": "**atan2(** _y_ , _x_ **)** Description: the radian value of the arctangent of _y_ / _x_ , where the signs of the parameters _y_ and _x_ are used to determine the quadrant of the answer Domain _y_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: -pi to pi\n\n",
    "atanh": "**atanh(** _x_ **)** Description: the inverse hyperbolic tangent of _x_ , **atanh(** _x_ **)** = (1/2){ln(1+ _x_ ) - ln(1- _x_ )} Domain: -1 to 1 Range: -8e+307 to 8e+307\n\n",
    "autocode": "**autocode(** _x_ **,** _n_ **,** _x0_ **,** _x1_ **)** Description: partitions the interval from _x0_ to _x1_ into _n_ equal-length intervals and returns the upper bound of the interval that contains _x_\n\nThis function is an automated version of [**recode()**](https://www.stata.com/help.cgi?recode\\(\\)). See **[U] 25 Working with categorical data and factor** **variables** for an example. Domain _x_ : -8e+307 to 8e+307 Domain _n_ : integers 1 to 8e+307 Domain _x0_ : -8e+307 to 8e+307 Domain _x1_ : _x0_ to 8e+307 Range: _x0_ to _x1_\n\n",
    "betaden": "**betaden(** _a_ **,** _b_ **,** _x_ **)** Description: the probability density of the beta distribution, where _a_ and _b_ are shape parameters; **0** if _x_ < 0 or _x_ > 1 Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _x_ _<_ 1 Range: 0 to 8e+307\n\n",
    "binomial": "**binomial(** _n_ **,** _k_ **,** _p_ **)** Description: the probability of observing [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _k_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)) or fewer successes in **floor(** _n_ **)** trials when the probability of a success on one trial is _p_ ; **0** if _k_ < 0; or **1** if _k_ > _n_ Domain _n_ : 0 to 1e+17 Domain _k_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _k_ < _n_ Domain _p_ : 0 to 1 Range: 0 to 1\n\n",
    "binomialp": "**binomialp(** _n_ **,** _k_ **,** _p_ **)** Description: the probability of observing [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _k_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)) successes in **floor(** _n_ **)** trials when the probability of a success on one trial is _p_ Domain _n_ : 1 to 1e+6 Domain _k_ : 0 to n Domain _p_ : 0 to 1 Range: 0 to 1\n\n",
    "binomialtail": "**binomialtail(** _n_ **,** _k_ **,** _p_ **)** Description: the probability of observing [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _k_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)) or more successes in **floor(** _n_ **)** trials when the probability of a success on one trial is _p_ ; **1** if _k_ < 0; or **0** if _k_ > _n_ Domain _n_ : 0 to 1e+17 Domain _k_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _k_ < _n_ Domain _p_ : 0 to 1 Range: 0 to 1\n\n",
    "binormal": "**binormal(** _h_ **,** _k_ **,** _r_ **)** Description: the joint cumulative distribution of the bivariate normal with correlation _r_ Cumulative over (-inf, _h_ ] x (-inf, _k_ ] Domain _h_ : -8e+307 to 8e+307 Domain _k_ : -8e+307 to 8e+307 Domain _r_ : -1 to 1 Range: 0 to 1\n\n",
    "bofd": "**bofd(\"** _cal_ **\",** _e_d_ **)** Description: the _e_b_ business date corresponding to _e_d_ Domain _cal_ : business calendar names and formats Domain _e_d_ : **%td** as defined by business calendar named _cal_ Range: as defined by business calendar named _cal_\n\n",
    "byteorder": "**byteorder()** Description: **1** if your computer stores numbers by using a hilo byte order and evaluates to **2** if your computer stores numbers by using a lohi byte order\n\nConsider the number 1 written as a 2-byte integer. On some computers (called hilo), it is written as \"00 01\", and on other computers (called lohi), it is written as \"01 00\" (with the least significant byte written first). There are similar issues for 4-byte integers, 4-byte floats, and 8-byte floats. Stata automatically handles byte-order differences for Stata-created files. Users need not be concerned about this issue. Programmers producing custom binary files can use **byteorder()** to determine the native byte ordering; see [**[P] file**](https://www.stata.com/help.cgi?file). Range: 1 and 2\n\n",
    "c": "**c(** _name_ **)** Description: the value of the system or constant result **c(** _name_ **)** See [**[P] creturn**](https://www.stata.com/help.cgi?creturn). Referencing **c(** _name_ **)** will return an error if the result does not exist. Domain: names Range: real values, strings, or _missing_\n\n",
    "cauchy": "**cauchy(** _a_ **,** _b_ **,** _x_ **)** Description: the cumulative Cauchy distribution with location parameter _a_ and scale parameter _b_ Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "cauchyden": "**cauchyden(** _a_ **,** _b_ **,** _x_ **)** Description: the probability density of the Cauchy distribution with location parameter _a_ and scale parameter _b_ Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "cauchytail": "**cauchytail(** _a_ **,** _b_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) Cauchy distribution with location parameter _a_ and scale parameter _b_\n\n**cauchytail(** _a_ **,** _b_ **,** _x_ **)** = 1 - **cauchy(** _a_ **,** _b_ **,** _x_ **)** Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "Cdhms": "**Cdhms(** _e_d_ **,** _h_ **,** _m_ **,** _s_ **)** Description: the _e_tC_ datetime (ms. with leap seconds since 01jan1960 00:00:00.000) corresponding to _e_d_ , _h_ , _m_ , _s_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Domain _h_ : integers 0 to 23 Domain _m_ : integers 0 to 59 Domain _s_ : reals 0.000 to 60.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) and _missing_\n\n",
    "ceil": "**ceil(** _x_ **)** Description: the unique integer _n_ such that _n_ \\- 1  < _x_ _<_ _n_ ; _x_ (not \" **.** \") if _x_ is missing, meaning that **ceil(.a)** = **.a**\n\nAlso see [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _x_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)), [**int(**](https://www.stata.com/help.cgi?int\\(\\))[ _x_](https://www.stata.com/help.cgi?int\\(\\))[ **)**](https://www.stata.com/help.cgi?int\\(\\)), and [**round(**](https://www.stata.com/help.cgi?round\\(\\))[ _x_](https://www.stata.com/help.cgi?round\\(\\))[ **)**](https://www.stata.com/help.cgi?round\\(\\)). Domain: -8e+307 to 8e+307 Range: integers in -8e+307 to 8e+307\n\n",
    "char": "**char(** _n_ **)** Description: the character corresponding to ASCII or extended ASCII code _n_ ; **\"\"** if _n_ is not in the domain Note: ASCII codes are from 0 to 127; extended ASCII codes are from 128 to 255. Prior to Stata 14, the display of extended ASCII characters was encoding dependent. For example, **char(128)** on Microsoft Windows using Windows-1252 encoding displayed the Euro symbol, but on Linux using ISO-Latin-1 encoding, **char(128)** displayed an invalid character symbol. Beginning with Stata 14, Stata's display encoding is UTF-8 on all platforms. The **char(128)** function is an invalid UTF-8 sequence and thus will display a question mark. There are two Unicode functions corresponding to **char()** : **uchar()** and **ustrunescape()**. You can use **uchar(8364)** or **ustrunescape(\"\\u20AC\")** to display a Euro sign on all platforms. Domain _n_ : integers 0 to 255 Range: ASCII characters\n\n",
    "chi2": "**chi2(** _df_ **,** _x_ **)** Description: the cumulative chi-squared distribution with _df_ degrees of freedom; **0** if _x_ < 0\n\n**chi2(** _df_ **,** _x_ **)** = [**gammap(**](https://www.stata.com/help.cgi?gammap\\(\\))[ _df_](https://www.stata.com/help.cgi?gammap\\(\\))[/2](https://www.stata.com/help.cgi?gammap\\(\\))[ **,**](https://www.stata.com/help.cgi?gammap\\(\\))[ _x_](https://www.stata.com/help.cgi?gammap\\(\\))[/2](https://www.stata.com/help.cgi?gammap\\(\\))[ **)**](https://www.stata.com/help.cgi?gammap\\(\\)) Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "chi2den": "**chi2den(** _df_ **,** _x_ **)** Description: the probability density of the chi-squared distribution with _df_ degrees of freedom; **0** if _x_ < 0 **chi2den(** _df_ **,** _x_ **)** = [**gammaden(**](https://www.stata.com/help.cgi?gammaden\\(\\))[ _df_](https://www.stata.com/help.cgi?gammaden\\(\\))[/2](https://www.stata.com/help.cgi?gammaden\\(\\))[ **,**](https://www.stata.com/help.cgi?gammaden\\(\\))[2](https://www.stata.com/help.cgi?gammaden\\(\\))[ **,**](https://www.stata.com/help.cgi?gammaden\\(\\))[0](https://www.stata.com/help.cgi?gammaden\\(\\))[ **,**](https://www.stata.com/help.cgi?gammaden\\(\\))[ _x_](https://www.stata.com/help.cgi?gammaden\\(\\))[ **)**](https://www.stata.com/help.cgi?gammaden\\(\\)) Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "chi2tail": "**chi2tail(** _df_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) chi-squared distribution with _df_ degrees of freedom; **1** if _x_ < 0\n\n**chi2tail(** _df_ **,** _x_ **)** = 1 - **chi2(** _df_ **,** _x_ **)** Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "Chms": "**Chms(** _h_ **,** _m_ **,** _s_ **)** Description: the _e_tC_ datetime (ms. with leap seconds since 01jan1960 00:00:00.000) corresponding to _h_ , _m_ , _s_ on 01jan1960 Domain _h_ : integers 0 to 23 Domain _m_ : integers 0 to 59 Domain _s_ : reals 0.000 to 60.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) and _missing_\n\n",
    "cholesky": "**cholesky(** _M_ **)** Description: the Cholesky decomposition of the matrix: if _R_ = **cholesky(** _S_ **)** , then _RR_ ^T = _S_\n\n_R_ ^T indicates the transpose of _R_. Row and column names are obtained from _M_. Domain: _n_ x _n_ , positive-definite, symmetric matrices Range: _n_ x _n_ lower-triangular matrices\n\n",
    "chop": "**chop(** _x_ **,** _tol_ **)** Description: **round(** _x_ **)** if **abs(** _x_ **-round(** _x_ **))** < _tol_ ; otherwise, _x_ ; or _x_ if _x_ is missing Domain _x_ : -8e+307 to 8e+307 Domain _tol_ : -8e+307 to 8e+307 Range: -8e+307 to 8e+307\n\n",
    "clip": "**clip(** _x_ **,** _a_ **,** _b_ **)** Description: _x_ if _a_ < _x_ < _b_ , _b_ if _x_ _>_ _b_ , _a_ if _x_ _<_ _a_ , or _missing_ if _x_ is missing or if _a_ > _b_ ; _x_ if _x_ is missing\n\nIf _a_ or _b_ is missing, this is interpreted as _a_ = -inf or _b_ = +inf, respectively. Domain _x_ : -8e+307 to 8e+307 Domain _a_ : -8e+307 to 8e+307 Domain _b_ : -8e+307 to 8e+307 Range: -8e+307 to 8e+307\n\n",
    "Clock": "**Clock(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_tC_ datetime (ms. with leap seconds since 01jan1960 00:00:00.000) corresponding to _s1_ based on _s2_ and _Y_\n\nFunction **Clock()** works the same as function **clock()** except that **Clock()** returns a leap second-adjusted **%tC** value rather than an unadjusted **%tc** value. Use **Clock()** only if original time values have been adjusted for leap seconds. Domain _s1_ : strings Domain _s2_ : strings Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) and _missing_\n\n**clock(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_tc_ datetime (ms. since 01jan1960 00:00:00.000) corresponding to _s1_ based on _s2_ and _Y_\n\n_s1_ contains the date, time, or both, recorded as a string, in virtually any format. Months can be spelled out, abbreviated (to three characters), or indicated as numbers; years can include or exclude the century; blanks and punctuation are allowed.\n\n_s2_ is any permutation of **M** , **D** , [ _##_ ] **Y** , **h** , **m** , and **s** , with their order defining the order that month, day, year, hour, minute, and second occur (and whether they occur) in _s1_. _##_ , if specified, indicates the default century for two-digit years in _s1_. For instance, _s2_ = **\"MD19Y** **hm\"** would translate _s1_ = **\"11/15/91 21:14\"** as 15nov1991 21:14. The space in **\"MD19Y hm\"** was not significant and the string would have translated just as well with **\"MD19Yhm\"**.\n\n_Y_ provides an alternate way of handling two-digit years. _Y_ specifies the largest year that is to be returned when a two-digit year is encountered; see [**date()**](https://www.stata.com/help.cgi?date\\(\\)). If neither _##_ nor _Y_ is specified, **clock()** returns _missing_ when it encounters a two-digit year. Domain _s1_ : strings Domain _s2_ : strings Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) and _missing_\n\n",
    "cloglog": "**cloglog(** _x_ **)** Description: the complementary log-log of _x_ **cloglog(** _x_ **)** = ln{-ln(1- _x_ )} Domain: 0 to 1 Range: -8e+307 to 8e+307\n\n",
    "Cmdyhms": "**Cmdyhms(** _M_ **,** _D_ **,** _Y_ **,** _h_ **,** _m_ **,** _s_ **)** Description: the _e_tC_ datetime (ms. with leap seconds since 01jan1960 00:00:00.000) corresponding to _M_ , _D_ , _Y_ , _h_ , _m_ , _s_ Domain _M_ : integers 1 to 12 Domain _D_ : integers 1 to 31 Domain _Y_ : integers 0100 to 9999 (but probably 1800 to 2100) Domain _h_ : integers 0 to 23 Domain _m_ : integers 0 to 59 Domain _s_ : reals 0.000 to 60.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) and _missing_\n\n",
    "Cofc": "**Cofc(** _e_tc_ **)** Description: the _e_tC_ datetime (ms. with leap seconds since 01jan1960 00:00:00.000) of _e_tc_ (ms. without leap seconds since 01jan1960 00:00:00.000) Domain _e_tc_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999)\n\n**cofC(** _e_tC_ **)** Description: the _e_tc_ datetime (ms. without leap seconds since 01jan1960 00:00:00.000) of _e_tC_ (ms. with leap seconds since 01jan1960 00:00:00.000) Domain _e_tC_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999)\n\n",
    "Cofd": "**Cofd(** _e_d_ **)** Description: the _e_tC_ datetime (ms. with leap seconds since 01jan1960 00:00:00.000) of date _e_d_ at time 00:00:00.000 Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to  >253,717,919,999,999)\n\n**cofd(** _e_d_ **)** Description: the _e_tc_ datetime (ms. since 01jan1960 00:00:00.000) of date _e_d_ at time 00:00:00.000 Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999)\n\n",
    "coleqnumb": "**coleqnumb(** _M_ **,** _s_ **)** Description: the equation number of _M_ associated with column equation _s_ ; _missing_ if the column equation cannot be found Domain _M_ : matrices Domain _s_ : strings Range: integer scalars 1 to **matsize** or _missing_\n\n",
    "collatorlocale": "**collatorlocale(** _loc_ **,** _type_ **)** Description: the most closely related locale supported by ICU from _loc_ if _type_ is **1** ; the actual locale where the collation data comes from if _type_ is **2**\n\nFor any other _type_ , _loc_ is returned in a canonicalized form.\n\n**collatorlocale(\"en_us_texas\", 0)** = **en_US_TEXAS** **collatorlocale(\"en_us_texas\", 1)** = **en_US** **collatorlocale(\"en_us_texas\", 2)** = **root** Domain _loc_ : strings of locale name Domain _type_ : integers Range: strings\n\n",
    "collatorversion": "**collatorversion(** _loc_ **)** Description: the version string of a collator based on locale _loc_\n\nThe Unicode standard is constantly adding more characters and the sort key format may change as well. This can cause [**ustrsortkey()**](https://www.stata.com/help.cgi?f_ustrsortkey) and [**ustrsortkeyex()**](https://www.stata.com/help.cgi?f_ustrsortkeyex) to produce incompatible sort keys between different versions of International Components for Unicode. The version string can be used for versioning the sort keys to indicate when saved sort keys must be regenerated. Range: strings\n\n",
    "colnfreeparms": "**colnfreeparms(** _M_ **)** Description: the number of free parameters in columns of _M_ Domain _M_ : matrices Range: integer scalars 0 to **matsize**\n\n",
    "colnumb": "**colnumb(** _M_ **,** _s_ **)** Description: the column number of _M_ associated with column name _s_ ; _missing_ if the column cannot be found Domain _M_ : matrices Domain _s_ : strings Range: integer scalars 1 to **matsize** or _missing_\n\n",
    "colsof": "**colsof(** _M_ **)** Description: the number of columns of _M_ Domain: matrices Range: integer scalars 1 to **matsize**\n\n",
    "comb": "**comb(** _n_ **,** _k_ **)** Description: the combinatorial function _n_!/{ _k_!( _n_ \\- _k_ )!} Domain _n_ : integers 1 to 1e+305 Domain _k_ : integers 0 to _n_ Range: 0 to 8e+307 or _missing_\n\n",
    "cond": "**cond(** _x_ **,** _a_ **,** _b_ [ **,** _c_ ] **)** Description: _a_ if _x_ is true and nonmissing, _b_ if _x_ is false, and _c_ if _x_ is _missing_ ; _a_ if _c_ is not specified and _x_ evaluates to _missing_\n\nNote that expressions such as _x_ >2 will never evaluate to _missing_.\n\n**cond(x >2,50,70)** returns **50** if **x** > **2** (includes **x** _>_ **.** ) **cond(x >2,50,70)** returns **70** if **x** _<_ **2**\n\nIf you need a case for missing values in the above examples, try\n\n**cond(missing(x), ., cond(x >2,50,70))** returns **.** if **x** is _missing_ , returns **50** if **x** > **2** , and returns **70** if **x** _<_ **2**\n\nIf the first argument is a scalar that may contain a missing value or a variable containing missing values, the fourth argument has an effect.\n\n**cond(wage,1,0,.)** returns **1** if **wage** is not zero and not missing **cond(wage,1,0,.)** returns **0** if **wage** is zero **cond(wage,1,0,.)** returns **.** if **wage** is _missing_\n\nCaution: If the first argument to **cond()** is a logical expression, that is, **cond(x >2,50,70,.)**, the fourth argument is never reached. Domain _x_ : -8e+307 to 8e+307 or _missing_ ; 0 means false, otherwise interpreted as true Domain _a_ : numbers and strings Domain _b_ : numbers if _a_ is a number; strings if _a_ is a string Domain _c_ : numbers if _a_ is a number; strings if _a_ is a string Range: _a_ , _b_ , and _c_\n\n",
    "corr": "**corr(** _M_ **)** Description: the correlation matrix of the variance matrix\n\nRow and column names are obtained from _M_. Domain: _n_ x _n_ symmetric variance matrices Range: _n_ x _n_ symmetric correlation matrices\n\n",
    "cos": "**cos(** _x_ **)** Description: the cosine of _x_ , where _x_ is in radians Domain: -1e+18 to 1e+18 Range: -1 to 1\n\n",
    "cosh": "**cosh(** _x_ **)** Description: the hyperbolic cosine of _x_ , **cosh(** _x_ **)** = {exp( _x_ ) + exp(- _x_ )}/2 Domain: -709 to 709 Range: 1 to 4.11e+307\n\n",
    "date": "**date(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_d_ date (days since 01jan1960) corresponding to _s1_ based on _s2_ and _Y_\n\n_s1_ contains the date, recorded as a string, in virtually any format. Months can be spelled out, abbreviated (to three characters), or indicated as numbers; years can include or exclude the century; blanks and punctuation are allowed.\n\n_s2_ is any permutation of **M** , **D** , and [ _##_ ] _Y_ , with their order defining the order that month, day, and year occur in _s1_. _##_ , if specified, indicates the default century for two-digit years in _s1_. For instance, _s2_ = **\"MD19Y\"** would translate _s1_ = **\"11/15/91\"** as 15nov1991.\n\n_Y_ provides an alternate way of handling two-digit years. When a two-digit year is encountered, the largest year, _topyear_ , that does not exceed _Y_ is returned.\n\n**date(\"1/15/08\",\"MDY\",1999)** = 15jan1908 **date(\"1/15/08\",\"MDY\",2019)** = 15jan2008\n\n**date(\"1/15/51\",\"MDY\",2000)** = 15jan1951 **date(\"1/15/50\",\"MDY\",2000)** = 15jan1950 **date(\"1/15/49\",\"MDY\",2000)** = 15jan1949\n\n**date(\"1/15/01\",\"MDY\",2050)** = 15jan2001 **date(\"1/15/00\",\"MDY\",2050)** = 15jan2000\n\nIf neither _##_ nor _Y_ is specified, **date()** returns _missing_ when it encounters a two-digit year. See [_Working with_](https://www.stata.com/help.cgi?datetime+translation#twodigit) [_two- digit years_](https://www.stata.com/help.cgi?datetime+translation#twodigit) in [**[D] datetime translation**](https://www.stata.com/help.cgi?datetime+translation) for more information. Domain _s1_ : strings Domain _s2_ : strings Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) or _missing_\n\n**daily(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: a synonym for **date(** _s1_ **,** _s2_ [ **,** _Y_ ] **)**\n\n",
    "day": "**day(** _e_d_ **)** Description: the numeric day of the month corresponding to _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 1 to 31 or _missing_\n\n",
    "det": "**det(** _M_ **)** Description: the determinant of matrix _M_ Domain: _n_ x _n_ (square) matrices Range: scalars -8e+307 to 8e+307\n\n",
    "dgammapda": "**dgammapda(** _a_ **,** _x_ **)** Description: the partial derivative of the cumulative gamma distribution **gammap(** _a_ **,** _x_ **)** with respect to _a_ , for _a_ > 0; **0** if _x_ < 0 Domain _a_ : 1e-7 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: -16 to 0\n\n",
    "dgammapdada": "**dgammapdada(** _a_ **,** _x_ **)** Description: the 2nd partial derivative of the cumulative gamma distribution **gammap(** _a_ **,** _x_ **)** with respect to _a_ , for _a_ > 0; **0** if _x_ < 0 Domain _a_ : 1e-7 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: -0.02 to 4.77e+5\n\n",
    "dgammapdadx": "**dgammapdadx(** _a_ **,** _x_ **)** Description: the 2nd partial derivative of the cumulative gamma distribution **gammap(** _a_ **,** _x_ **)** with respect to _a_ and _x_ , for _a_ > 0; **0** if _x_ < 0 Domain _a_ : 1e-7 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: -0.04 to 8e+307\n\n",
    "dgammapdx": "**dgammapdx(** _a_ **,** _x_ **)** Description: the partial derivative of the cumulative gamma distribution **gammap(** _a_ **,** _x_ **)** with respect to _x_ , for _a_ > 0; **0** if _x_ < 0 Domain _a_ : 1e-10 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 8e+307\n\n",
    "dgammapdxdx": "**dgammapdxdx(** _a_ **,** _x_ **)** Description: the 2nd partial derivative of the cumulative gamma distribution **gammap(** _a_ **,** _x_ **)** with respect to _x_ , for _a_ > 0; **0** if _x_ < 0 Domain _a_ : 1e-10 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1e+40\n\n",
    "dhms": "**dhms(** _e_d_ **,** _h_ **,** _m_ **,** _s_ **)** Description: the _e_tc_ datetime (ms. since 01jan1960 00:00:00.000) corresponding to _e_d_ , _h_ , _m_ , _s_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Domain _h_ : integers 0 to 23 Domain _m_ : integers 0 to 59 Domain _s_ : reals 0.000 to 59.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) and _missing_\n\n",
    "diag": "**diag(** _M_ **)** Description: the square, diagonal matrix created from the row or column vector\n\nRow and column names are obtained from the column names of _M_ if _M_ is a row vector or from the row names of _M_ if _M_ is a column vector. Domain: 1 x _n_ and _n_ x 1 vectors Range: _n_ x _n_ diagonal matrices\n\n",
    "diag0cnt": "**diag0cnt(** _M_ **)** Description: the number of zeros on the diagonal of _M_ Domain: _n_ x _n_ (square) matrices Range: integer scalars 0 to _n_\n\n",
    "digamma": "**digamma(** _x_ **)** Description: the **digamma()** function\n\nThis is the derivative of **lngamma(** _x_ **)**. The **digamma(** _x_ **)** function is sometimes called the psi function. Domain: -1e+15 to 8e+307 Range: -8e+307 to 8e+307 or _missing_\n\n",
    "dofb": "**dofb(** _e_b_ **,\"** _cal_ **\")** Description: the _e_d_ datetime corresponding to _e_b_ Domain _e_b_ : **%tb** as defined by business calendar named _cal_ Domain _cal_ : business calendar names and formats Range: as defined by business calendar named _cal_\n\n",
    "dofC": "**dofC(** _e_tC_ **)** Description: the _e_d_ date (days since 01jan1960) of datetime _e_tC_ (ms. with leap seconds since 01jan1960 00:00:00.000) Domain _e_tC_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) Range: **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549)\n\n**dofc(** _e_tc_ **)** Description: the _e_d_ date (days since 01jan1960) of datetime _e_tC_ (ms. since 01jan1960 00:00:00.000) Domain _e_tc_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) Range: **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549)\n\n",
    "dofh": "**dofh(** _e_h_ **)** Description: the _e_d_ date (days since 01jan1960) of the start of half-year _e_h_ Domain _e_h_ : **%th** dates 0100h1 to 9999h2 (integers -3,720 to 16,079) Range: **%td** dates 01jan0100 to 01jul9999 (integers -679,350 to 2,936,366)\n\n",
    "dofm": "**dofm(** _e_m_ **)** Description: the _e_d_ date (days since 01jan1960) of the start of month _e_m_ Domain _e_m_ : **%tm** dates 0100m1 to 9999m12 (integers -22,320 to 96,479) Range: **%td** dates 01jan0100 to 01dec9999 (integers -679,350 to 2,936,519)\n\n",
    "dofq": "**dofq(** _e_q_ **)** Description: the _e_d_ date (days since 01jan1960) of the start of quarter _e_q_ Domain _e_q_ : **%tq** dates 0100q1 to 9999q4 (integers -7,440 to 32,159) Range: **%td** dates 01jan0100 to 01oct9999 (integers -679,350 to 2,936,458)\n\n",
    "dofw": "**dofw(** _e_w_ **)** Description: the _e_d_ date (days since 01jan1960) of the start of week _e_w_ Domain _e_w_ : **%tw** dates 0100w1 to 9999w52 (integers -96,720 to 418,079) Range: **%td** dates 01jan0100 to 24dec9999 (integers -679,350 to 2,936,542)\n\n",
    "dofy": "**dofy(** _e_y_ **)** Description: the _e_d_ date (days since 01jan1960) of 01jan in year _e_y_ Domain _e_y_ : **%ty** dates 0100 to 9999 (integers 0100 to 9999) Range: **%td** dates 01jan0100 to 01jan9999 (integers -679,350 to 2,936,185)\n\n",
    "dow": "**dow(** _e_d_ **)** Description: the numeric day of the week corresponding to date _e_d_ ; 0 = Sunday, 1 = Monday, ..., 6 = Saturday Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 0 to 6 or _missing_\n\n",
    "doy": "**doy(** _e_d_ **)** Description: the numeric day of the year corresponding to date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 1 to 366 or _missing_\n\n",
    "dunnettprob": "**dunnettprob(** _k_ **,** _df_ **,** _x_ **)** Description: the cumulative multiple range distribution that is used in Dunnett's multiple-comparison method with _k_ ranges and _df_ degrees of freedom; **0** if _x_ < 0\n\n**dunnettprob()** is computed using an algorithm described in [Miller (1981)](https://www.stata.com/help.cgi?density_functions#M1981). Domain _k_ : 2 to 1e+6 Domain _df_ : 2 to 1e+6 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n**_Reference_**\n\nMiller, R. G. 1981. _Simultaneous Statistical Inference_. 2nd ed. New York: Springer.\n\n",
    "e": "**e(** _name_ **)** Description: the value of stored result **e(** _name_ **)** ; see **[U] 18.8** **Accessing results calculated by other programs**\n\n**e(** _name_ **)** = scalar missing if the stored result does not exist **e(** _name_ **)** = specified matrix if the stored result is a matrix **e(** _name_ **)** = scalar numeric value if the stored result is a scalar Domain: names Range: strings, scalars, matrices, or _missing_\n\n**e(sample)** Description: **1** if the observation is in the estimation sample and **0** otherwise Range: 0 to 1\n\n",
    "el": "**el(** _s_ **,** _i_ **,** _j_ **)** Description: _s_ **[floor(** _i_ **),floor(** _j_ **)]** , the _i_ , _j_ element of the matrix named _s_ ; missing if _i_ or _j_ are out of range or if matrix _s_ does not exist Domain _s_ : strings containing matrix name Domain _i_ : scalars 1 to **matsize** Domain _j_ : scalars 1 to **matsize** Range: scalars -8e+307 to 8e+307 or _missing_\n\n",
    "epsdouble": "**epsdouble()** Description: the machine precision of a double-precision number If _d_ < **epsdouble()** and (double) _x_ = 1, then _x_ \\+ _d_ = (double) 1. This function takes no arguments, but the parentheses must be included. Range: a double-precision number close to 0\n\n",
    "epsfloat": "**epsfloat()** Description: the machine precision of a floating-point number\n\nIf _d_ < **epsfloat()** and (float) _x_ = 1, then _x_ \\+ _d_ = (float) 1. This function takes no arguments, but the parentheses must be included. Range: a floating-point number close to 0\n\n",
    "exp": "**exp(** _x_ **)** Description: the exponential function of _e_ ^ _x_\n\nThis function is the inverse of **ln(** _x_ **)**. Domain: -8e+307 to 709 Range: 0 to 8e+307\n\n",
    "exponential": "**exponential(** _b_ **,** _x_ **)** Description: the cumulative exponential distribution with scale _b_\n\nThe cumulative distribution function of the exponential distribution is\n\n1 - exp(- _x_ / _b_ )\n\nfor _x_ _>_ 0 and 0 for _x_ < 0, where _b_ is the scale and _x_ is the value of an exponential variate. The mean of the exponential distribution is _b_ and its variance is _b_ ^2. Domain _b_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "exponentialden": "**exponentialden(** _b_ **,** _x_ **)** Description: the probability density function of the exponential distribution with scale _b_\n\nThe probability density function of the exponential distribution is\n\n1/ _b_ exp(- _x_ / _b_ )\n\nwhere _b_ is the scale and _x_ is the value of an exponential variate. Domain _b_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 1e-323 to 8e+307\n\n",
    "exponentialtail": "**exponentialtail(** _b_ **,** _x_ **)** Description: the reverse cumulative exponential distribution with scale _b_\n\nThe reverse cumulative distribution function of the exponential distribution is\n\nexp(- _x_ / _b_ )\n\nwhere _b_ is the scale and _x_ is the value of an exponential variate. Domain _b_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "F": "**F(** _df1_ **,** _df2_ **,** _f_ **)** Description: the cumulative F distribution with _df1_ numerator and _df2_ denominator degrees of freedom; **0** if _f_ < 0 Domain _df1_ : 2e-10 to 2e+17 (may be nonintegral) Domain _df2_ : 2e-10 to 2e+17 (may be nonintegral) Domain _f_ : -8e+307 to 8e+307; interesting domain is _f_ _>_ 0 Range: 0 to 1\n\n",
    "Fden": "**Fden(** _df1_ **,** _df2_ **,** _f_ **)** Description: the probability density function for the F distribution with _df1_ numerator and _df2_ denominator degrees of freedom; **0** if _f_ < 0 Domain _df1_ : 1e-323 to 8e+307 (may be nonintegral) Domain _df2_ : 1e-323 to 8e+307 (may be nonintegral) Domain _f_ : -8e+307 to 8e+307; interesting domain is _f_ _>_ 0 Range: 0 to 8e+307\n\n",
    "fileexists": "**fileexists(** _f_ **)** Description: **1** if the file specified by _f_ exists; otherwise, **0**\n\nIf the file exists but is not readable, **fileexists()** will still return **1** , because it does exist. If the \"file\" is a directory, **fileexists()** will return **0**. Domain: filenames Range: 0 and 1\n\n",
    "fileread": "**fileread(** _f_ **)** Description: the contents of the file specified by _f_\n\nIf the file does not exist or an I/O error occurs while reading the file, then \" **fileread() error** _#_ \" is returned, where _#_ is a standard Stata error return code. Domain: filenames Range: strings\n\n",
    "filereaderror": "**filereaderror(** _s_ **)** Description: **0** or positive integer, said value having the interpretation of a return code\n\nIt is used like this\n\n**. generate strL** _s_ **= fileread(** _filename_ **) if** **fileexists(** _filename_ **)** **. assert filereaderror(** _s_ **)==0**\n\nor this\n\n**. generate strL** _s_ **= fileread(** _filename_ **) if** **fileexists(** _filename_ **)** **. generate** _rc_ **= filereaderror(** _s_ **)**\n\nThat is, **filereaderror(** _s_ **)** is used on the result returned by **fileread(** _filename_ **)** to determine whether an I/O error occurred.\n\nIn the example, we only **fileread()** files that **fileexists()**. That is not required. If the file does not exist, that will be detected by **filereaderror()** as an error. The way we showed the example, we did not want to read missing files as errors. If we wanted to treat missing files as errors, we would have coded\n\n**. generate strL** _s_ **= fileread(** _filename_ **)** **. assert filereaderror(** _s_ **)==0**\n\nor\n\n**. generate strL** _s_ **= fileread(** _filename_ **)** **. generate** _rc_ **= filereaderror(** _s_ **)** Domain: strings Range: integers\n\n",
    "filewrite": "**filewrite(** _f_ **,** _s_ [ **,** _r_ ] **)** Description: writes the string specified by _s_ to the file specified by _f_ and returns the number of bytes in the resulting file\n\nIf the optional argument _r_ is specified as 1, the file specified by _f_ will be replaced if it exists. If _r_ is specified as 2, the file specified by _f_ will be appended to if it exists. Any other values of _r_ are treated as if _r_ were not specified; that is, _f_ will only be written to if it does not already exist.\n\nWhen the file _f_ is freshly created or is replaced, the value returned by **filewrite()** is the number of bytes written to the file, **strlen(** _s_ **)**. If _r_ is specified as 2, and thus **filewrite()** is appending to an existing file, the value returned is the total number of bytes in the resulting file; that is, the value is the sum of the number of the bytes in the file as it existed before **filewrite()** was called and the number of bytes newly written to it, **strlen(** _s_ **)**.\n\nIf the file exists and _r_ is not specified as 1 or 2, or an error occurs while writing to the file, then a negative number ( _#_ ) is returned, where **abs(** _#_ **)** is a standard Stata error return code. Domain _f_ : filenames Domain _s_ : strings Domain _r_ : integers 1 or 2 Range: integers\n\n",
    "float": "**float(** _x_ **)** Description: the value of _x_ rounded to **float** precision\n\nAlthough you may store your numeric variables as **byte** , **int** , **long** , **float** , or **double** , Stata converts all numbers to **double** before performing any calculations. Consequently, difficulties can arise in comparing numbers that have no finite binary representations.\n\nFor example, if the variable **x** is stored as a **float** and contains the value **1.1** (a repeating \"decimal\" in binary), the expression **x==1.1** will evaluate to _false_ because the literal **1.1** is the **double** representation of 1.1, which is different from the **float** representation stored in **x**. (They differ by 2.384 x 10^(-8).) The expression **x==float(1.1)** will evaluate to _true_ because the **float()** function converts the literal **1.1** to its **float** representation before it is compared with **x**. (See **[U] 13.12 Precision and problems therein** for more information.) Domain: -1e+38 to 1e+38 Range: -1e+38 to 1e+38\n\n",
    "floor": "**floor(** _x_ **)** Description: the unique integer _n_ such that _n_ _<_ _x_ < _n_ \\+ 1; _x_ (not \" **.** \") if _x_ is missing, meaning that **floor(.a)** = **.a**\n\nAlso see [**ceil(**](https://www.stata.com/help.cgi?ceil\\(\\))[ _x_](https://www.stata.com/help.cgi?ceil\\(\\))[ **)**](https://www.stata.com/help.cgi?ceil\\(\\)), [**int(**](https://www.stata.com/help.cgi?int\\(\\))[ _x_](https://www.stata.com/help.cgi?int\\(\\))[ **)**](https://www.stata.com/help.cgi?int\\(\\)), and [**round(**](https://www.stata.com/help.cgi?round\\(\\))[ _x_](https://www.stata.com/help.cgi?round\\(\\))[ **)**](https://www.stata.com/help.cgi?round\\(\\)). Domain: -8e+307 to 8e+307 Range: integers in -8e+307 to 8e+307\n\n",
    "fmtwidth": "**fmtwidth(** _fmtstr_ **)** Description: the output length of the **%** _fmt_ contained in _fmtstr_ ; _missing_ if _fmtstr_ does not contain a valid **%** _fmt_\n\nFor example, **fmtwidth(\"%9.2f\")** returns **9** and **fmtwidth(\"%tc\")** returns **18**. Range: strings\n\n",
    "Ftail": "**Ftail(** _df1_ **,** _df2_ **,** _f_ **)** Description: the reverse cumulative (upper tail or survivor) F distribution with _df1_ numerator and _df2_ denominator degrees of freedom; **1** if _f_ < 0\n\n**Ftail(** _df1_ **,** _df2_ **,** _f_ **)** = 1 - **F(** _df1_ **,** _df2_ **,** _f_ **)** Domain _df1_ : 2e-10 to 2e+17 (may be nonintegral) Domain _df2_ : 2e-10 to 2e+17 (may be nonintegral) Domain _f_ : -8e+307 to 8e+307; interesting domain is _f_ _>_ 0 Range: 0 to 1\n\n",
    "gammaden": "**gammaden(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the probability density function of the gamma distribution; **0** if _x_ < _g_\n\n_a_ is the shape parameter, _b_ is the scale parameter, and _g_ is the location parameter. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 8e+307\n\n",
    "gammap": "**gammap(** _a_ **,** _x_ **)** Description: the cumulative gamma distribution with shape parameter _a_ ; **0** if _x_ < 0\n\nThe cumulative Poisson (the probability of observing _k_ or fewer events if the expected is _x_ ) can be evaluated as **1-gammap(** _k_ **+1,** _x_ **)**. The reverse cumulative (the probability of observing _k_ or more events) can be evaluated as **gammap(** _k_ **,** _x_ **)**.\n\n**gammap()** is also known as the incomplete gamma function (ratio). Probabilities for the three-parameter gamma distribution (see [**gammaden()**](https://www.stata.com/help.cgi?gammaden\\(\\))) can be calculated by shifting and scaling _x_ ; that is, **gammap(** _a_ **,** ( _x_ \\- _g_ )/ _b_ **)**. Domain _a_ : 1e-10 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "gammaptail": "**gammaptail(** _a_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) gamma distribution with shape parameter _a_ ; **1** if _x_ < 0\n\n**gammaptail()** is also known as the complement to the incomplete gamma function (ratio). Domain _a_ : 1e-10 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "hadamard": "**hadamard(** _M_ **,** _N_ **)** Description: a matrix whose _i_ , _j_ element is _M_ [ _i_ , _j_ ]* _N_ [ _i_ , _j_ ] (if _M_ and _N_ are not the same size, this function reports a conformability error) Domain _M_ : _m_ x _n_ matrices Domain _N_ : _m_ x _n_ matrices Range: _m_ x _n_ matrices\n\n",
    "halfyear": "**halfyear(** _e_d_ **)** Description: the numeric half of the year corresponding to date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 1, 2, or _missing_\n\n",
    "halfyearly": "**halfyearly(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_h_ half-yearly date (half-years since 1960h1) corresponding to _s1_ based on _s2_ and _Y_ ; _Y_ specifies _topyear_ ; see [**date()**](https://www.stata.com/help.cgi?date\\(\\)) Domain _s1_ : strings Domain _s2_ : strings **\"HY\"** and **\"YH\"** ; **Y** may be prefixed with _##_ Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: **%th** dates 0100h1 to 9999h2 (integers -3,720 to 16,079) or _missing_\n\n",
    "has_eprop": "**has_eprop(** _name_ **)** Description: **1** if _name_ appears as a word in **e(properties)** ; otherwise, **0** Domain: names Range: 0 or 1\n\n",
    "hh": "**hh(** _e_tc_ **)** Description: the hour corresponding to datetime _e_tc_ (ms. since 01jan1960 00:00:00.000) Domain _e_tc_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) Range: integers 0 through 23, _missing_\n\n",
    "hhC": "**hhC(** _e_tC_ **)** Description: the hour corresponding to datetime _e_tC_ (ms. with leap seconds since 01jan1960 00:00:00.000) Domain _e_tC_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) Range: integers 0 through 23, _missing_\n\n",
    "hms": "**hms(** _h_ **,** _m_ **,** _s_ **)** Description: the _e_tc_ datetimes (ms. since 01jan1960 00:00:00.000) corresponding to _h_ , _m_ , _s_ on 01jan1960 Domain _h_ : integers 0 to 23 Domain _m_ : integers 0 to 59 Domain _s_ : reals 0.000 to 59.999 Range: datetimes 01jan1960 00:00:00.000 to 01jan1960 23:59:59.999 (integers 0 to 86,399,999 or _missing_ )\n\n",
    "hofd": "**hofd(** _e_d_ **)** Description: the _e_h_ half-yearly date (half years since 1960h1) containing date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: **%th** dates 0100h1 to 9999h2 (integers -3,720 to 16,079)\n\n",
    "hours": "**hours(** _ms_ **)** Description: _ms_ /3,600,000 Domain _ms_ : real; milliseconds Range: real or _missing_\n\n",
    "hypergeometric": "**hypergeometric(** _N_ **,** _K_ **,** _n_ **,** _k_ **)** Description: the cumulative probability of the hypergeometric distribution _N_ is the population size, _K_ is the number of elements in the population that have the attribute of interest, and _n_ is the sample size. Returned is the probability of observing _k_ or fewer elements from a sample of size _n_ that have the attribute of interest. Domain _N_ : 2 to 1e+5 Domain _K_ : 1 to _N_ -1 Domain _n_ : 1 to _N_ -1 Domain _k_ : **max(** 0 **,** _n-N+K_ **)** to **min(** _K_ **,** _n_ **)** Range: 0 to 1\n\n",
    "hypergeometricp": "**hypergeometricp(** _N_ **,** _K_ **,** _n_ **,** _k_ **)** Description: the hypergeometric probability of _k_ successes out of a sample of size _n_ , from a population of size _N_ containing _K_ elements that have the attribute of interest\n\nSuccess is obtaining an element with the attribute of interest. Domain _N_ : 2 to 1e+5 Domain _K_ : 1 to _N_ -1 Domain _n_ : 1 to _N_ -1 Domain _k_ : **max(** 0 **,** _n-N+K_ **)** to **min(** _K_ **,** _n_ **)** Range: 0 to 1 (right exclusive)\n\n",
    "I": "**I(** _n_ **)** Description: an _n_ x _n_ identity matrix if _n_ is an integer; otherwise, a **round(** _n_ **)** x **round(** _n_ **)** identity matrix Domain: real scalars 1 to **matsize** Range: identity matrices\n\n",
    "ibeta": "**ibeta(** _a_ **,** _b_ **,** _x_ **)** Description: the cumulative beta distribution with shape parameters _a_ and _b_ ; **0** if _x_ < 0; **1** if _x_ > 1\n\n**ibeta()** returns the regularized incomplete beta function, also known as the incomplete beta function ratio. The incomplete beta function without regularization is given by **(gamma(** _a_ **)*gamma(** _b_ **)/gamma(** _a_ **+** _b_ **))*ibeta(** _a_ **,** _b_ **,** _x_ **)** or, better when _a_ or _b_ might be large, **exp(lngamma(** _a_ **)+lngamma(** _b_ **)-lngamma(** _a_ **+** _b_ **))*ibeta(** _a_ **,** _b_ **,** _x_ **)**.\n\nHere is an example of the use of the regularized incomplete beta function. Although Stata has a cumulative binomial function (see [**binomial()**](https://www.stata.com/help.cgi?f_binomiallc)), the probability that an event occurs _k_ or fewer times in _n_ trials, when the probability of one event is _p_ , can be evaluated as **cond(** _k_ **==** _n_ **,1,1-ibeta(** _k_ **+1,** _n_ **-** _k_ **,** _p_ **))**. The reverse cumulative binomial (the probability that an event occurs _k_ or more times) can be evaluated as **cond(** _k_ **==0,1,ibeta(** _k_ **,** _n_ **-** _k_ **+1,** _p_ **))**. Domain _a_ : 1e-10 to 1e+17 Domain _b_ : 1e-10 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _x_ _<_ 1 Range: 0 to 1\n\n",
    "ibetatail": "**ibetatail(** _a_ **,** _b_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) beta distribution with shape parameters _a_ and _b_ ; **1** if _x_ < 0; **0** if _x_ > 1\n\n**ibetatail()** is also known as the complement to the incomplete beta function (ratio). Domain _a_ : 1e-10 to 1e+17 Domain _b_ : 1e-10 to 1e+17 Domain _x_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _x_ _<_ 1 Range: 0 to 1\n\n",
    "igaussian": "**igaussian(** _m_ **,** _a_ **,** _x_ **)** Description: the cumulative inverse Gaussian distribution with mean _m_ and shape parameter _a_ ; **0** if x _<_ 0 Domain _m_ : 1e-323 to 8e+307 Domain _a_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "igaussianden": "**igaussianden(** _m_ **,** _a_ **,** _x_ **)** Description: the probability density of the inverse Gaussian distribution with mean _m_ and shape parameter _a_ ; **0** if x _<_ 0 Domain _m_ : 1e-323 to 8e+307 Domain _a_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "igaussiantail": "**igaussiantail(** _m_ **,** _a_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) inverse Gaussian distribution with mean _m_ and shape parameter _a_ ; **1** if x _<_ 0\n\n**igaussiantail(** _m_ **,** _a_ **,** _x_ **)** = 1 - **igaussian(** _m_ **,** _a_ **,** _x_ **)** Domain _m_ : 1e-323 to 8e+307 Domain _a_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "indexnot": "**indexnot(** _s1_ **,** _s2_ **)** Description: the position in ASCII string _s1_ of the first character of _s1_ not found in ASCII string _s2_ , or **0** if all characters of _s1_ are found in _s2_\n\n**indexnot()** is intended for use with only plain ASCII strings. For Unicode characters beyond the plain ASCII range, the position and character are given in bytes, not characters. Domain _s1_ : ASCII strings (to be searched) Domain _s2_ : ASCII strings (to search for) Range: integers _>_ 0\n\n",
    "inlist": "**inlist(** _z_ **,** _a_ **,** _b_ **,** _..._ **)** Description: **1** if _z_ is a member of the remaining arguments; otherwise, **0** All arguments must be reals or all must be strings. The number of arguments is between 2 and 255 for reals and between 2 and 10 for strings. Domain: all reals or all strings Range: 0 or 1\n\n",
    "inrange": "**inrange(** _z_ **,** _a_ **,** _b_ **)** Description: **1** if it is known that _a_ _<_ _z_ _<_ _b_ ; otherwise, **0** The following ordered rules apply: _z_ _>_ **.** returns **0**. _a_ _>_ **.** and _b_ = **.** returns **1**. _a_ _>_ **.** returns **1** if _z_ _<_ _b_ ; otherwise, it returns **0**. _b_ _>_ **.** returns **1** if _a_ _<_ _z_ ; otherwise, it returns **0**. Otherwise, **1** is returned if _a_ _<_ _z_ _<_ _b_. If the arguments are strings, \" **.** \" is interpreted as **\"\"**. Domain: all reals or all strings Range: 0 or 1\n\n",
    "int": "**int(** _x_ **)** Description: the integer obtained by truncating _x_ toward 0 (thus, **int(5.2)** = 5 and **int(-5.8)** = -5); _x_ (not \" **.** \") if _x_ is missing, meaning that **int(.a)** = **.a**\n\nOne way to obtain the closest integer to _x_ is **int(** _x_ **+sign(** _x_ **)/2)** , which simplifies to **int(** _x_ **+0.5)** for _x_ _>_ 0\\. However, use of the **round()** function is preferred. Also see [**round(**](https://www.stata.com/help.cgi?round\\(\\))[ _x_](https://www.stata.com/help.cgi?round\\(\\))[ **)**](https://www.stata.com/help.cgi?round\\(\\)), [**ceil(**](https://www.stata.com/help.cgi?ceil\\(\\))[ _x_](https://www.stata.com/help.cgi?ceil\\(\\))[ **)**](https://www.stata.com/help.cgi?ceil\\(\\)), and [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _x_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)). Domain: -8e+307 to 8e+307 Range: integers in -8e+307 to 8e+307\n\n**trunc(** _x_ **)** Description: a synonym for [**int(**](https://www.stata.com/help.cgi?int\\(\\))[ _x_](https://www.stata.com/help.cgi?int\\(\\))[ **)**](https://www.stata.com/help.cgi?int\\(\\))\n\n",
    "inv": "**inv(** _M_ **)** Description: the inverse of the matrix _M_\n\nIf _M_ is singular, this will result in an error.\n\nThe function [**invsym()**](https://www.stata.com/help.cgi?invsym\\(\\)) should be used in preference to **inv()** because **invsym()** is more accurate. The row names of the result are obtained from the column names of _M_ , and the column names of the result are obtained from the row names of _M_. Domain: _n_ x _n_ nonsingular matrices Range: _n_ x _n_ matrices\n\n",
    "invbinomial": "**invbinomial(** _n_ **,** _k_ **,** _p_ **)** Description: the inverse of the cumulative binomial; that is, the probability of success on one trial such that the probability of observing [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _k_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)) or fewer successes in **floor(** _n_ **)** trials is _p_ Domain _n_ : 1 to 1e+17 Domain _k_ : 0 to _n_ \\- 1 Domain _p_ : 0 to 1 (exclusive) Range: 0 to 1\n\n",
    "invbinomialtail": "**invbinomialtail(** _n_ **,** _k_ **,** _p_ **)** Description: the inverse of the right cumulative binomial; that is, the probability of success on one trial such that the probability of observing [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _k_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)) or more successes in **floor(** _n_ **)** trials is _p_ Domain _n_ : 1 to 1e+17 Domain _k_ : 1 to _n_ Domain _p_ : 0 to 1 (exclusive) Range: 0 to 1\n\n",
    "invcauchy": "**invcauchy(** _a_ **,** _b_ **,** _p_ **)** Description: the inverse of **cauchy()** : if **cauchy(** _a_ **,** _b_ **,** _x_ **)** = _p_ , then **invcauchy(** _a_ **,** _b_ **,** _p_ **)** = _x_ Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Domain _p_ : 0 to 1 (exclusive) Range: -8e+307 to 8e+307\n\n",
    "invcauchytail": "**invcauchytail(** _a_ **,** _b_ **,** _p_ **)** Description the inverse of **cauchytail()** : if **cauchytail(** _a_ **,** _b_ **,** _x_ **)** = _p_ , then **invcauchytail(** _a_ **,** _b_ **,** _p_ **)** = _x_ Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Domain _p_ : 0 to 1 (exclusive) Range: -8e+307 to 8e+307\n\n",
    "invchi2": "**invchi2(** _df_ **,** _p_ **)** Description: the inverse of **chi2()** : if **chi2(** _df_ **,** x **)** = _p_ , then **invchi2(** _df_ **,** _p_ **)** = _x_ Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invchi2tail": "**invchi2tail(** _df_ **,** _p_ **)** Description: the inverse of **chi2tail()** : if **chi2tail(** _df_ **,** x **)** = _p_ , then **invchi2tail(** _df_ **,** _p_ **)** = _x_ Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invcloglog": "**invcloglog(** _x_ **)** Description: the inverse of the complementary log- log function of _x_ **invcloglog(** _x_ **)** = 1 - exp{-exp( _x_ )} Domain: -8e+307 to 8e+307 Range: 0 to 1 or _missing_\n\n",
    "invdunnettprob": "**invdunnettprob(** _k_ **,** _df_ **,** _p_ **)** Description: the inverse cumulative multiple range distribution that is used in Dunnett's multiple- comparison method with _k_ ranges and _df_ degrees of freedom If **dunnettprob(** _k_ **,** _df_ **,** _x_ **)** = _p_ , then **invdunnettprob(** _k_ **,** _df_ **,** _p_ **)** = _x_. **invdunnettprob()** is computed using an algorithm described in [Miller (1981)](https://www.stata.com/help.cgi?density_functions#M1981). Domain _k_ : 2 to 1e+6 Domain _df_ : 2 to 1e+6 Domain _p_ : 0 to 1 (right exclusive) Range: 0 to 8e+307\n\n**_Reference_**\n\nMiller, R. G. 1981. _Simultaneous Statistical Inference_. 2nd ed. New York: Springer.\n\n",
    "invexponential": "**invexponential(** _b_ **,** _p_ **)** Description: the inverse cumulative exponential distribution with scale _b_ : if **exponential(** _b_ **,** _x_ **)** = _p_ , then **invexponential(** _b_ **,** _p_ **)** = _x_ Domain _b_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: 1e-323 to 8e+307\n\n",
    "invexponentialtail": "**invexponentialtail(** _b_ **,** _p_ **)** Description: the inverse reverse cumulative exponential distribution with scale _b_ : if **exponentialtail(** _b_ **,** _x_ **)** = _p_ , then **invexponential(** _b_ **,** _p_ **)** = _x_ Domain _b_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: 1e-323 to 8e+307\n\n",
    "invF": "**invF(** _df1_ **,** _df2_ **,** _p_ **)** Description: the inverse cumulative F distribution: if **F(** _df1_ **,** _df2_ **,** f **)** = _p_ , then **invF(** _df1_ **,** _df2_ **,** _p_ **)** = _f_ Domain _df1_ : 2e-10 to 2e+17 (may be nonintegral) Domain _df2_ : 2e-10 to 2e+17 (may be nonintegral) Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invFtail": "**invFtail(** _df1_ **,** _df2_ **,** _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) F distribution: if **Ftail(** _df1_ **,** _df2_ **,** f **)** = _p_ , then **invFtail(** _df1_ **,** _df2_ **,** _p_ **)** = f Domain _df1_ : 2e-10 to 2e+17 (may be nonintegral) Domain _df2_ : 2e-10 to 2e+17 (may be nonintegral) Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invgammap": "**invgammap(** _a_ **,** _p_ **)** Description: the inverse cumulative gamma distribution: if **gammap(** _a_ **,** x **)** = _p_ , then **invgammap(** _a_ **,** _p_ **)** = _x_ Domain _a_ : 1e-10 to 1e+17 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invgammaptail": "**invgammaptail(** _a_ **,** _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) gamma distribution: if **gammaptail(** _a_ **,** _x_ **)** = _p_ , then **invgammaptail(** _a_ **,** _p_ **)** = _x_ Domain _a_ : 1e-10 to 1e+17 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invibeta": "**invibeta(** _a_ **,** _b_ , _p_ **)** Description: the inverse cumulative beta distribution: if **ibeta(** _a_ **,** _b_ **,** x **)** = _p_ , then **invibeta(** _a_ **,** _b_ , _p_ **)** = _x_ Domain _a_ : 1e-10 to 1e+17 Domain _b_ : 1e-10 to 1e+17 Domain _p_ : 0 to 1 Range: 0 to 1\n\n",
    "invibetatail": "**invibetatail(** _a_ **,** _b_ , _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) beta distribution: if **ibetatail(** _a_ **,** _b_ **,** x **)** = _p_ , then **invibetatail(** _a_ **,** _b_ , _p_ **)** = _x_ Domain _a_ : 1e-10 to 1e+17 Domain _b_ : 1e-10 to 1e+17 Domain _p_ : 0 to 1 Range: 0 to 1\n\n",
    "invigaussian": "**invigaussian(** _m_ **,** _a_ **,** _p_ **)** Description: the inverse of **igaussian()** : if **igaussian(** _m_ **,** _a_ **,** _x_ **)** = _p_ , then **invigaussian(** _m_ **,** _a_ **,** _p_ **)** = _x_ Domain _m_ : 1e-323 to 8e+307 Domain _a_ : 1e-323 to 1e+8 Domain _p_ : 0 to 1 (exclusive) Range: 0 to 8e+307\n\n",
    "invigaussiantail": "**invigaussiantail(** _m_ **,** _a_ **,** _p_ **)** Description the inverse of **igaussiantail()** : if **igaussiantail(** _m_ **,** _a_ **,** _x_ **)** = _p_ , then **invigaussiantail(** _m_ **,** _a_ **,** _p_ **)** = _x_ Domain _m_ : 1e-323 to 8e+307 Domain _a_ : 1e-323 to 1e+8 Domain _p_ : 0 to 1 (exclusive) Range: 0 to 8e+307\n\n",
    "invlaplace": "**invlaplace(** _m_ **,** _b_ **,** _p_ **)** Description: the inverse of **laplace()** : if **laplace(** _m_ **,** _b_ **,** _x_ **)** = _p_ , then **invlaplace(** _m_ **,** _b_ **,** _p_ **)** = _x_ Domain _m_ : -8e+307 to 8e+307 Domain _b_ : 1e-307 to 8e+307 Domain _p_ : 0 to 1 (exclusive) Range: -8e+307 to 8e+307\n\n",
    "invlaplacetail": "**invlaplacetail(** _m_ **,** _b_ **,** _p_ **)** Description the inverse of **laplacetail()** : if **laplacetail(** _m_ **,** _b_ **,** _x_ **)** = _p_ , then **invlaplacetail(** _m_ **,** _b_ **,** _p_ **)** = _x_ Domain _m_ : -8e+307 to 8e+307 Domain _b_ : 1e-307 to 8e+307 Domain _p_ : 0 to 1 (exclusive) Range: -8e+307 to 8e+307\n\n",
    "invlogistic": "**invlogistic(** _p_ **)** Description: the inverse cumulative logistic distribution: if **logistic(** _x_ **)** = _p_ , then **invlogistic(** _p_ **)** = _x_ Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n**invlogistic(** _s_ **,** _p_ **)** Description: the inverse cumulative logistic distribution: if **logistic(** _s_ **,** _x_ **)** = _p_ , then **invlogistic(** _s_ **,** _p_ **)** = _x_ Domain _s_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n**invlogistic(** _m_ **,** _s_ **,** _p_ **)** Description: the inverse cumulative logistic distribution: if **logistic(** _m_ **,** _s_ **,** _x_ **)** = _p_ , then **invlogistic(** _m_ **,** _s_ **,** _p_ **)** = _x_ Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n",
    "invlogistictail": "**invlogistictail(** _p_ **)** Description: the inverse reverse cumulative logistic distribution: if **logistictail(** _x_ **)** = _p_ , then **invlogistictail(** _p_ **)** = _x_ Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n**invlogistictail(** _s_ **,** _p_ **)** Description: the inverse reverse cumulative logistic distribution: if **logistictail(** _s_ **,** _x_ **)** = _p_ , then **invlogistictail(** _s_ **,** _p_ **)** = _x_ Domain _s_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n**invlogistictail(** _m_ **,** _s_ **,** _p_ **)** Description: the inverse reverse cumulative logistic distribution: if **logistictail(** _m_ **,** _s_ **,** _x_ **)** = _p_ , then **invlogistictail(** _m_ **,** _s_ **,** _p_ **)** = _x_ Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n",
    "invlogit": "**invlogit(** _x_ **)** Description: the inverse of the logit function of _x_ **invlogit(** _x_ **)** = exp( _x_ )/{1 + exp( _x_ )} Domain: -8e+307 to 8e+307 Range: 0 to 1 or _missing_\n\n",
    "invnbinomial": "**invnbinomial(** _n_ **,** _k_ **,** _q_ **)** Description: the value of the negative binomial parameter, _p_ , such that _q =_ **nbinomial(** _n_ **,** _k_ **,** _p_ **)**\n\n**invnbinomial()** is evaluated using [**invibeta()**](https://www.stata.com/help.cgi?invibeta\\(\\)). Domain _n_ : 1e-10 to 1e+17 (can be nonintegral) Domain _k_ : 0 to 2^53-1 Domain _q_ : 0 to 1 (exclusive) Range: 0 to 1\n\n",
    "invnbinomialtail": "**invnbinomialtail(** _n_ **,** _k_ **,** _q_ **)** Description: the value of the negative binomial parameter, _p_ , such that _q =_ **nbinomialtail(** _n_ **,** _k_ **,** _p_ **)**\n\n**invnbinomialtail()** is evaluated using [**invibetatail()**](https://www.stata.com/help.cgi?invibetatail\\(\\)). Domain _n_ : 1e-10 to 1e+17 (can be nonintegral) Domain _k_ : 1 to 2^53-1 Domain _q_ : 0 to 1 (exclusive) Range: 0 to 1 (exclusive)\n\n",
    "invnchi2": "**invnchi2(** _df_ **,** _np_ **,** _p_ **)** Description: the inverse cumulative noncentral chi-squared distribution: if **nchi2(** _df_ **,** _np_ **,** x **)** = _p_ , then **invnchi2(** _df_ **,** _np_ **,** _p_ **)** = _x_ Domain _df_ : 2e-10 to 1e+6 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invnchi2tail": "**invnchi2tail(** _df_ **,** _np_ **,** _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) noncentral chi-squared distribution: if **nchi2tail(** _df_ **,** _np_ **,** _x_ **)** = _p_ , then **invnchi2tail(** _df_ **,** _np_ **,** _p_ **)** = _x_ Domain _df_ : 2e-10 to 1e+6 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invnF": "**invnF(** _df1_ **,** _df2_ **,** _np_ **,** _p_ **)** Description: the inverse cumulative noncentral F distribution: if **nF(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** = _p_ , then **invnF(** _df1_ **,** _df2_ **,** _np_ **,** _p_ **)** = _f_ Domain _df1_ : 1e-6 to 1e+6 (may be nonintegral) Domain _df2_ : 1e-6 to 1e+6 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invnFtail": "**invnFtail(** _df1_ **,** _df2_ **,** _np_ **,** _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) noncentral F distribution: if **nFtail(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** = _p_ , then **invnFtail(** _df1_ **,** _df2_ **,** _np_ **,** _p_ **)** = _f_ Domain _df1_ : 1e-323 to 8e+307 (may be nonintegral) Domain _df2_ : 1e-323 to 8e+307 (may be nonintegral) Domain _np_ : 0 to 1,000 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n",
    "invnibeta": "**invnibeta(** _a_ **,** _b_ **,** _np_ **,** _p_ **)** Description: the inverse cumulative noncentral beta distribution: if **nibeta(** _a_ **,** _b_ **,** _np_ **,** x **)** = _p_ , then **invnibeta(** _a_ **,** _b_ **,** _np_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _np_ : 0 to 1,000 Domain _p_ : 0 to 1 Range: 0 to 1\n\n",
    "invnormal": "**invnormal(** _p_ **)** Description: the inverse cumulative standard normal distribution: if **normal(** _z_ **)** = _p_ , then **invnormal(** _p_ **)** = _z_ Domain: 1e-323 to 1 - 2^(-53) Range: -38.449394 to 8.2095362\n\n",
    "invnt": "**invnt(** _df_ **,** _np_ **,** _p_ **)** Description: the inverse cumulative noncentral Student's t distribution: if **nt(** _df_ **,** _np_ **,** _t_ **)** = _p_ , then **invnt(** _df_ **,** _np_ **,** _p_ **)** = _t_ Domain _df_ : 1 to 1e+6 (may be nonintegral) Domain _np_ : -1,000 to 1,000 Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n",
    "invnttail": "**invnttail(** _df_ **,** _np_ **,** _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) noncentral Student's t distribution: if **nttail(** _df_ **,** _np_ **,** _t_ **)** = _p_ , then **invnttail(** _df_ **,** _np_ **,** _p_ **)** = _t_ Domain _df_ : 1 to 1e+6 (may be nonintegral) Domain _np_ : -1,000 to 1,000 Domain _p_ : 0 to 1 Range: -8e+10 to 8e+10\n\n",
    "invpoisson": "**invpoisson(** _k_ **,** _p_ **)** Description: the Poisson mean such that the cumulative Poisson distribution evaluated at _k_ is _p_ : if **poisson(** _m_ **,** k **)** = _p_ , then **invpoisson(** _k_ **,** _p_ **)** = _m_\n\nThe inverse Poisson distribution function is evaluated using [**invgammaptail()**](https://www.stata.com/help.cgi?invgammaptail\\(\\)). Domain _k_ : 0 to 2^53-1 Domain _p_ : 0 to 1 (exclusive) Range: 1.110e-16 to 2^53\n\n",
    "invpoissontail": "**invpoissontail(** _k_ **,** _q_ **)** Description: the Poisson mean such that the reverse cumulative Poisson distribution evaluated at _k_ is _q_ : if **poissontail(** _m_ **,** k **)** = _q_ , then **invpoissontail(** _k_ **,** _q_ **)** = _m_\n\nThe inverse of the reverse cumulative Poisson distribution function is evaluated using [**invgammap()**](https://www.stata.com/help.cgi?invgammap\\(\\)). Domain _k_ : 0 to 2^53-1 Domain _q_ : 0 to 1 (exclusive) Range: 0 to 2^53 (left exclusive)\n\n",
    "invsym": "**invsym(** _M_ **)** Description: the inverse of _M_ if _M_ is positive definite\n\nIf _M_ is not positive definite, rows will be inverted until the diagonal terms are zero or negative; the rows and columns corresponding to these terms will be set to 0, producing a g2 inverse. The row names of the result are obtained from the column names of _M_ , and the column names of the result are obtained from the row names of _M_. Domain: _n_ x _n_ symmetric matrices Range: _n_ x _n_ symmetric matrices\n\n",
    "invt": "**invt(** _df_ **,** _p_ **)** Description: the inverse cumulative Student's t distribution: if **t(** _df_ **,** _t_ **)** = _p_ , then **invt(** _df_ **,** _p_ **)** = _t_ Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n",
    "invttail": "**invttail(** _df_ **,** _p_ **)** Description: the inverse reverse cumulative (upper tail or survivor) Student's t distribution: if **ttail(** _df_ **,** _t_ **)** = _p_ , then **invttail(** _df_ **,** _p_ **)** = _t_ Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _p_ : 0 to 1 Range: -8e+307 to 8e+307\n\n",
    "invtukeyprob": "**invtukeyprob(** _k_ **,** _df_ **,** _p_ **)** Description: the inverse cumulative Tukey's Studentized range distribution with _k_ ranges and _df_ degrees of freedom\n\nIf _df_ is a missing value, then the normal distribution is used instead of Student's t. If **tukeyprob(** _k_ **,** _df_ **,** x **)** = _p_ , then **invtukeyprob(** _k_ **,** _df_ **,** _p_ **)** = x. **invtukeyprob()** is computed using an algorithm described in [Miller (1981)](https://www.stata.com/help.cgi?density_functions#M1981). Domain _k_ : 2 to 1e+6 Domain _df_ : 2 to 1e+6 Domain _p_ : 0 to 1 Range: 0 to 8e+307\n\n**_Reference_**\n\nMiller, R. G. 1981. _Simultaneous Statistical Inference_. 2nd ed. New York: Springer.\n\n",
    "invweibull": "**invweibull(** _a_ **,** _b_ **,** _p_ **)** Description: the inverse cumulative Weibull distribution with shape _a_ and scale _b_ : if **weibull(** _a_ **,** _b_ **,** _x_ **)** = _p_ , then **invweibull(** _a_ **,** _b_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: 1e-323 to 8e+307\n\n**invweibull(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** Description: the inverse cumulative Weibull distribution with shape _a_ , scale _b_ , and location _g_ : if **weibull(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** = _p_ , then **invweibull(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _p_ : 0 to 1 Range: _g_ + **c(epsdouble)** to 8e+307\n\n",
    "invweibullph": "**invweibullph(** _a_ **,** _b_ **,** _p_ **)** Description: the inverse cumulative Weibull (proportional hazards) distribution with shape _a_ and scale _b_ : if **weibullph(** _a_ **,** _b_ **,** _x_ **)** = _p_ , then **invweibullph(** _a_ **,** _b_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: 1e-323 to 8e+307\n\n**invweibullph(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** Description: the inverse cumulative Weibull (proportional hazards) distribution with shape _a_ , scale _b_ , and location _g_ : if **weibullph(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** = _p_ , then **invweibullph(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _p_ : 0 to 1 Range: _g_ + **c(epsdouble)** to 8e+307\n\n",
    "invweibullphtail": "**invweibullphtail(** _a_ **,** _b_ **,** _p_ **)** Description: the inverse reverse cumulative Weibull (proportional hazards) distribution with shape _a_ and scale _b_ : if **weibullphtail(** _a_ **,** _b_ **,** _x_ **)** = _p_ , then **invweibullphtail(** _a_ **,** _b_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: 1e-323 to 8e+307\n\n**invweibullphtail(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** Description: the inverse reverse cumulative Weibull (proportional hazards) distribution with shape _a_ , scale _b_ , and location _g_ : if **weibullphtail(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** = _p_ , then **invweibullphtail(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _p_ : 0 to 1 Range: _g_ + **c(epsdouble)** to 8e+307\n\n",
    "invweibulltail": "**invweibulltail(** _a_ **,** _b_ **,** _p_ **)** Description: the inverse reverse cumulative Weibull distribution with shape _a_ and scale _b_ : if **weibulltail(** _a_ **,** _b_ **,** _x_ **)** = _p_ , then **invweibulltail(** _a_ **,** _b_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _p_ : 0 to 1 Range: 1e-323 to 8e+307\n\n**invweibulltail(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** Description: the inverse reverse cumulative Weibull distribution with shape _a_ , scale _b_ , and location _g_ : if **weibulltail(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** = _p_ , then **invweibulltail(** _a_ **,** _b_ **,** _g_ **,** _p_ **)** = _x_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _p_ : 0 to 1 Range: _g_ + **c(epsdouble)** to 8e+307\n\n",
    "irecode": "**irecode(** _x_ **,** _x1_ **,** _x2_ **,** _..._ **,** _xn_ **)** Description: _missing_ if _x_ is missing or _x1_ ,..., _xn_ is not weakly increasing; **0** if _x_ _<_ _x1_ ; **1** if _x1_ < _x_ _<_ _x2_ ; **2** if _x2_ < _x_ _<_ _x3_ ; ...; _n_ if _x_ > _xn_\n\nAlso see [**autocode()**](https://www.stata.com/help.cgi?autocode\\(\\)) and [**recode()**](https://www.stata.com/help.cgi?recode\\(\\)) for other styles of recode functions.\n\n**irecode(3, -10, -5, -3, -3, 0, 15, .)** = **5** Domain _x_ : -8e+307 to 8e+307 Domain _xi_ : -8e+307 to 8e+307 Range: nonnegative integers\n\n",
    "issymmetric": "**issymmetric(** _M_ **)** Description: **1** if the matrix is symmetric; otherwise, **0** Domain: matrices Range: integers 0 and 1\n\n",
    "J": "**J(** _r_ **,** _c_ **,** _z_ **)** Description: the _r_ x _c_ matrix containing elements _z_ Domain _r_ : integer scalars 1 to **matsize** Domain _c_ : integer scalars 1 to **matsize** Domain _z_ : scalars -8e+307 to 8e+307 Range: _r_ x _c_ matrices\n\n",
    "laplace": "**laplace(** _m_ **,** _b_ **,** _x_ **)** Description: the cumulative Laplace distribution with mean _m_ and scale parameter _b_ Domain _m_ : -8e+307 to 8e+307 Domain _b_ : 1e-307 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "laplaceden": "**laplaceden(** _m_ **,** _b_ **,** _x_ **)** Description: the probability density of the Laplace distribution with mean _m_ and scale parameter _b_ Domain _m_ : -8e+307 to 8e+307 Domain _b_ : 1e-307 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "laplacetail": "**laplacetail(** _m_ **,** _b_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) Laplace distribution with mean _m_ and scale parameter _b_\n\n**laplacetail(** _m_ **,** _b_ **,** _x_ **)** = 1 - **laplace(** _m_ **,** _b_ **,** _x_ **)** Domain _m_ : -8e+307 to 8e+307 Domain _b_ : 1e-307 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "ln": "**ln(** _x_ **)** Description: the natural logarithm, ln( _x_ )\n\nThis function is the inverse of **exp(** _x_ **)**. Domain: 1e-323 to 8e+307 Range: -744 to 709\n\n",
    "lncauchyden": "**lncauchyden(** _a_ **,** _b_ **,** _x_ **)** Description: the natural logarithm of the density of the Cauchy distribution with location parameter _a_ and scale parameter _b_ Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Domain _x_ : -8e+307 to 8e+307 Range: -1650 to 230\n\n",
    "lnfactorial": "**lnfactorial(** _n_ **)** Description: the natural log of _n_ factorial = ln( _n_!)\n\nTo calculate _n_!, use **round(exp(lnfactorial(** _n_ **)),1)** to ensure that the result is an integer. Logs of factorials are generally more useful than the factorials themselves because of overflow problems. Domain: integers 0 to 1e+305 Range: 0 to 8e+307\n\n",
    "lngamma": "**lngamma(** _x_ **)** Description: the natural log of the gamma function of _x_ For integer values of _x_ > 0, this is ln(( _x_ -1)!).\n\n**lngamma(** _x_ **)** for _x_ < 0 returns a number such that **exp(lngamma(** _x_ **))** is equal to the absolute value of the gamma function. That is, **lngamma(** _x_ **)** always returns a real (not complex) result. Domain: -2,147,483,648 to 1e+305 (excluding negative integers) Range: -8e+307 to 8e+307\n\n",
    "lnigammaden": "**lnigammaden(** _a_ **,** _b_ **,** _x_ **)** Description: the natural logarithm of the inverse gamma density, where _a_ is the shape parameter and _b_ is the scale parameter Domain _a_ : 1e-300 to 1e+300 Domain _b_ : 1e-300 to 1e+300 Domain _x_ : 1e-300 to 8e+307 Range: -8e+307 to 8e+307\n\n",
    "lnigaussianden": "**lnigaussianden(** _m_ **,** _a_ **,** _x_ **)** Description: the natural logarithm of the inverse Gaussian density with mean _m_ and shape parameter _a_ Domain _m_ : 1e-323 to 8e+307 Domain _a_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: -8e+307 to 8e+307\n\n",
    "lniwishartden": "**lniwishartden(** _df_ **,** _V_ **,** _X_ **)** Description: the natural logarithm of the density of the inverse Wishart distribution; missing if _df_ <= _n_ -1\n\n_df_ denotes the degrees of freedom, _V_ is the scale matrix, and _X_ is the inverse Wishart random matrix. Domain _df_ : 1 to 1e+100 (may be nonintegral) Domain _V_ : _n_ x _n_ , positive-definite, symmetric matrices Domain _X_ : _n_ x _n_ , positive-definite, symmetric matrices Range: -8e+307 to 8e+307\n\n",
    "lnlaplaceden": "**lnlaplaceden(** _m_ **,** _b_ **,** _x_ **)** Description: the natural logarithm of the density of the Laplace distribution with mean _m_ and scale parameter _b_ Domain _m_ : -8e+307 to 8e+307 Domain _b_ : 1e-307 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: -8e+307 to 707\n\n",
    "lnmvnormalden": "**lnmvnormalden(** _M_ **,** _V_ **,** _X_ **)** Description: the natural logarithm of the multivariate normal density\n\n_M_ is the mean vector, _V_ is the covariance matrix, and _X_ is the random vector. Domain _M_ : _1_ x _n_ and _n_ x _1_ vectors Domain _V_ : _n_ x _n_ , positive-definite, symmetric matrices Domain _X_ : _1_ x _n_ and _n_ x _1_ vectors Range: -8e+307 to 8e+307\n\n",
    "lnnormal": "**lnnormal(** _z_ **)** Description: the natural logarithm of the cumulative standard normal distribution Domain: -1e+99 to 8e+307 Range: -5e+197 to 0\n\n",
    "lnnormalden": "**lnnormalden(** _z_ **)** Description: the natural logarithm of the standard normal density Domain: -1e+154 to 1e+154 Range: -5e+307 to -0.91893853 = **lnnormalden(0)**\n\n**lnnormalden(** _x_ **,** _s_ **)** Description: the natural logarithm of the normal density with mean 0 and standard deviation _s_\n\n**lnnormalden(** _x_ **,1)** = **lnnormalden(** _x_ **)** and **lnnormalden(** _x_ **,** _s_ **)** = **lnnormalden(** _x/s_ **)** \\- ln( _s_ ) Domain _x_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Range: -5e+307 to 742.82799\n\n**lnnormalden(** _x_ **,** _m_ **,** _s_ **)** Description: the natural logarithm of the normal density with mean _m_ and standard deviation _s_\n\n**lnnormalden(** _x_ **,0,** _s_ **)** = **lnnormalden(** _x_ **,** _s_ **)** and **lnnormalden(** _x_ **,** _m_ **,** _s_ **)** = **lnnormalden(** ( _x_ - _m_ )/ _s_ **) -** ln( _s_ ) Domain _x_ : -8e+307 to 8e+307 Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Range: 1e-323 to 8e+307\n\n",
    "lnwishartden": "**lnwishartden(** _df_ **,** _V_ **,** _X_ **)** Description: the natural logarithm of the density of the Wishart distribution; missing if _df_ <= _n_ -1\n\n_df_ denotes the degrees of freedom, _V_ is the scale matrix, and _X_ is the Wishart random matrix. Domain _df_ : 1 to 1e+100 (may be nonintegral) Domain _V_ : _n_ x _n_ , positive-definite, symmetric matrices Domain _X_ : _n_ x _n_ , positive-definite, symmetric matrices Range: -8e+307 to 8e+307\n\n",
    "log": "**log(** _x_ **)** Description: the natural logarithm, ln( _x_ ); thus, a synonym for [**ln(**](https://www.stata.com/help.cgi?ln\\(\\))[ _x_](https://www.stata.com/help.cgi?ln\\(\\))[ **)**](https://www.stata.com/help.cgi?ln\\(\\)) Domain: 1e-323 to 8e+307 Range: -744 to 709\n\n",
    "log10": "**log10(** _x_ **)** Description: the base-10 logarithm of _x_ Domain: 1e-323 to 8e+307 Range: -323 to 308\n\n",
    "logistic": "**logistic(** _x_ **)** Description: the cumulative logistic distribution with mean 0 and standard deviation pi/sqrt(3)\n\n**logistic(** _x_ **)** = **logistic(1,** _x_ **)** = **logistic(0,1,** _x_ **)** , where _x_ is the value of a logistic random variable. Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n**logistic(** _s_ **,** _x_ **)** Description: the cumulative logistic distribution with mean 0, scale _s_ , and standard deviation _s_ pi/sqrt(3)\n\n**logistic(** _s_ **,** _x_ **)** = **logistic(0,** _s_ **,** _x_ **)** , where _s_ is the scale and _x_ is the value of a logistic random variable. Domain _s_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n**logistic(** _m_ **,** _s_ **,** _x_ **)** Description: the cumulative logistic distribution with mean _m_ , scale _s_ , and standard deviation _s_ pi/sqrt(3) Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "logisticden": "**logisticden(** _x_ **)** Description: the density of the logistic distribution with mean 0 and standard deviation pi/sqrt(3)\n\n**logisticden(** _x_ **)** = **logisticden(1,** _x_ **)** = **logisticden(0,1,** _x_ **)** , where _x_ is the value of a logistic random variable. Domain _x_ : -8e+307 to 8e+307 Range: 0 to 0.25\n\n**logisticden(** _s_ **,** _x_ **)** Description: the density of the logistic distribution with mean 0, scale _s_ , and standard deviation _s_ pi/sqrt(3)\n\n**logisticden(** _s_ **,** _x_ **)** = **logisticden(0,** _s_ **,** _x_ **)** , where _s_ is the scale and _x_ is the value of a logistic random variable. Domain _s_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n**logisticden(** _m_ **,** _s_ **,** _x_ **)** Description: the density of the logistic distribution with mean _m_ , scale _s_ , and standard deviation _s_ pi/sqrt(3) Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "logistictail": "**logistictail(** _x_ **)** Description: the reverse cumulative logistic distribution with mean 0 and standard deviation pi/sqrt(3)\n\n**logistictail(** _x_ **)** = **logistictail(1,** _x_ **)** = **logistictail(0,1,** _x_ **)** , where _x_ is the value of a logistic random variable. Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n**logistictail(** _s_ **,** _x_ **)** Description: the reverse cumulative logistic distribution with mean 0, scale _s_ , and standard deviation _s_ pi/sqrt(3)\n\n**logistictail(** _s_ **,** _x_ **)** = **logistictail(0,** _s_ **,** _x_ **)** , where _s_ is the scale and _x_ is the value of a logistic random variable. Domain _s_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n**logistictail(** _m_ **,** _s_ **,** _x_ **)** Description: the reverse cumulative logistic distribution with mean _m_ , scale _s_ , and standard deviation _s_ pi/sqrt(3) Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-323 to 8e+307 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "logit": "**logit(** _x_ **)** Description: the log of the odds ratio of _x_ , **logit(** _x_ **)** = ln{ _x_ /(1- _x_ )} Domain: 0 to 1 (exclusive) Range: -8e+307 to 8e+307 or _missing_\n\n",
    "matmissing": "**matmissing(** _M_ **)** Description: **1** if any elements of the matrix are missing; otherwise, **0** Domain: matrices Range: integers 0 and 1\n\n",
    "matrix": "**matrix(** _exp_ **)** Description: restricts name interpretation to scalars and matrices; see [**scalar()**](https://www.stata.com/help.cgi?scalar\\(\\)) Domain: any value expression Range: evaluation of _exp_\n\n",
    "matuniform": "**matuniform(** _r_ **,** _c_ **)** Description: the _r_ x _c_ matrices containing uniformly distributed pseudorandom numbers on the interval (0,1) Domain _r_ : integer scalars 1 to **matsize** Domain _c_ : integer scalars 1 to **matsize** Range: _r_ x _c_ matrices\n\n",
    "max": "**max(** _x1_ **,** _x2_ **,** _..._ **,** _xn_ **)** Description: the maximum value of _x1_ , _x2_ , ..., _xn_\n\nUnless all arguments are _missing_ , missing values are ignored. **max(2,10,.,7)** = **10** **max(.,.,.)** = **.** Domain _x1_ : -8e+307 to 8e+307 or _missing_ Domain _x2_ : -8e+307 to 8e+307 or _missing_ ... Domain _xn_ : -8e+307 to 8e+307 or _missing_ Range: -8e+307 to 8e+307 or _missing_\n\n",
    "maxbyte": "**maxbyte()** Description: the largest value that can be stored in storage type **byte** This function takes no arguments, but the parentheses must be included. Range: one integer number\n\n",
    "maxdouble": "**maxdouble()** Description: the largest value that can be stored in storage type **double** This function takes no arguments, but the parentheses must be included. Range: one double-precision number\n\n",
    "maxfloat": "**maxfloat()** Description: the largest value that can be stored in storage type **float** This function takes no arguments, but the parentheses must be included. Range: one floating-point number\n\n",
    "maxint": "**maxint()** Description: the largest value that can be stored in storage type **int** This function takes no arguments, but the parentheses must be included. Range: one integer number\n\n",
    "maxlong": "**maxlong()** Description: the largest value that can be stored in storage type **long** This function takes no arguments, but the parentheses must be included. Range: one integer number\n\n",
    "mdy": "**mdy(** _M_ **,** _D_ **,** _Y_ **)** Description: the _e_d_ date (days since 01jan1960) corresponding to _M_ , _D_ , _Y_ Domain _M_ : integers 1 to 12 Domain _D_ : integers 1 to 31 Domain _Y_ : integers 0100 to 9999 (but probably 1800 to 2100) Range: **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) or _missing_\n\n",
    "mdyhms": "**mdyhms(** _M_ **,** _D_ **,** _Y_ **,** _h_ **,** _m_ **,** _s_ **)** Description: the _e_tc_ datetime (ms. since 01jan1960 00:00:00.000) corresponding to _M_ , _D_ , _Y_ , _h_ , _m_ , _s_ Domain _M_ : integers 1 to 12 Domain _D_ : integers 1 to 31 Domain _Y_ : integers 0100 to 9999 (but probably 1800 to 2100) Domain _h_ : integers 0 to 23 Domain _m_ : integers 0 to 59 Domain _s_ : reals 0.000 to 59.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) and _missing_\n\n",
    "missing": "**missing(** _x1_ **,** _x2_ **,** _..._ **,** _xn_ **)** Description: **1** if any of the arguments evaluates to _missing_ ; otherwise, **0**\n\nStata has two concepts. of missing values: a numeric missing value ( **.** , **.a** , **.b** , ..., **.z** ) and a string missing value ( **\"\"** ). **missing()** returns **1** (meaning _true_ ) if any expression _xi_ evaluates to _missing_. If _x_ is numeric, **missing(** _x_ **)** is equivalent to _x_ _>_ **.**. If _x_ is string, **missing(** _x_ **)** is equivalent to _x_ **==\"\"**. Domain _xi_ : any string or numeric expression Range: 0 and 1\n\n**mi(** _x1_ **,** _x2_ **,** _..._ **,** _xn_ **)** Description: a synonym for [**missing(**](https://www.stata.com/help.cgi?missing\\(\\))[ _x1_](https://www.stata.com/help.cgi?missing\\(\\))[ **,**](https://www.stata.com/help.cgi?missing\\(\\))[ _x2_](https://www.stata.com/help.cgi?missing\\(\\))[ **,**](https://www.stata.com/help.cgi?missing\\(\\))[ _..._](https://www.stata.com/help.cgi?missing\\(\\))[ **,**](https://www.stata.com/help.cgi?missing\\(\\))[ _xn_](https://www.stata.com/help.cgi?missing\\(\\))[ **)**](https://www.stata.com/help.cgi?missing\\(\\))\n\n",
    "min": "**min(** _x1_ **,** _x2_ **,** _..._ **,** _xn_ **)** Description: the minimum value of _x1_ , _x2_ , ..., _xn_ Unless all arguments are _missing_ , missing values are ignored. **min(2,10,.,7)** = **2** **min(.,.,.)** = **.** Domain _x1_ : -8e+307 to 8e+307 or _missing_ Domain _x2_ : -8e+307 to 8e+307 or _missing_ ... Domain _xn_ : -8e+307 to 8e+307 or _missing_ Range: -8e+307 to 8e+307 or _missing_\n\n",
    "minbyte": "**minbyte()** Description: the smallest value that can be stored in storage type **byte** This function takes no arguments, but the parentheses must be included. Range: one integer number\n\n",
    "mindouble": "**mindouble()** Description: the smallest value that can be stored in storage type **double** This function takes no arguments, but the parentheses must be included. Range: one double-precision number\n\n",
    "minfloat": "**minfloat()** Description: the smallest value that can be stored in storage type **float** This function takes no arguments, but the parentheses must be included. Range: one floating-point number\n\n",
    "minint": "**minint()** Description: the smallest value that can be stored in storage type **int** This function takes no arguments, but the parentheses must be included. Range: one integer number\n\n",
    "minlong": "**minlong()** Description: the smallest value that can be stored in storage type **long** This function takes no arguments, but the parentheses must be included. Range: one integer number\n\n",
    "minutes": "**minutes(** _ms_ **)** Description: _ms_ /60,000 Domain _ms_ : real; milliseconds Range: real or _missing_\n\n",
    "mm": "**mm(** _e_tc_ **)** Description: the minute corresponding to datetime _e_tc_ (ms. since 01jan1960 00:00:00.000) Domain _e_tc_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) Range: integers 0 through 59, _missing_\n\n",
    "mmC": "**mmC(** _e_tC_ **)** Description: the minutes corresponding to datetime _e_tC_ (ms. with leap seconds since 01jan1960 00:00:00.000) Domain _e_tC_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) Range: integers 0 through 59, _missing_\n\n",
    "mod": "**mod(** _x_ **,** _y_ **)** Description: the modulus of _x_ with respect to _y_ **mod(** _x_ **,** _y_ **)** = _x_ \\- _y_ * **floor(** _x_ / _y_ **)** **mod(** _x_ **,0)** = **.** Domain _x_ : -8e+307 to 8e+307 Domain _y_ : 0 to 8e+307 Range: 0 to 8e+307\n\n",
    "mofd": "**mofd(** _e_d_ **)** Description: the _e_m_ monthly date (months since 1960m1) containing date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: **%tm** dates 0100m1 to 9999m12 (integers -22,320 to 96,479)\n\n",
    "month": "**month(** _e_d_ **)** Description: the numeric month corresponding to date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 1 to 12 or _missing_\n\n",
    "monthly": "**monthly(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_m_ monthly date (months since 1960m1) corresponding to _s1_ based on _s2_ and _Y_ ; _Y_ specifies _topyear_ ; see [**date()**](https://www.stata.com/help.cgi?date\\(\\)) Domain _s1_ : strings Domain _s2_ : strings **\"MY\"** and **\"YM\"** ; **Y** may be prefixed with _##_ Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: **%tm** dates 0100m1 to 9999m12 (integers -22,320 to 96,479) or _missing_\n\n",
    "mreldif": "**mreldif(** _X_ **,** _Y_ **)** Description: the relative difference of _X_ and _Y_ Domain _X_ : matrices Domain _Y_ : matrices with same number of rows and columns as _X_ Range: scalars -8e+307 to 8e+307\n\n",
    "msofhours": "**msofhours(** _h_ **)** Description: _h_ x 3,600,000 Domain _h_ : real; hours Range: real or _missing_ ; milliseconds\n\n",
    "msofminutes": "**msofminutes(** _m_ **)** Description: _m_ x 60,000 Domain _m_ : real; minutes Range: real or _missing_ ; milliseconds\n\n",
    "msofseconds": "**msofseconds(** _s_ **)** Description: _s_ x 1,000 Domain _s_ : real; seconds Range: real or _missing_ ; milliseconds\n\n",
    "nbetaden": "**nbetaden(** _a_ **,** _b_ **,** _np_ **,** _x_ **)** Description: the probability density function of the noncentral beta distribution; **0** if _x_ < 0 or _x_ > 1 _a_ and _b_ are shape parameters, _np_ is the noncentrality parameter, and _x_ is the value of a beta random variable.\n\n**nbetaden(** _a_ **,** _b_ **,0,** _x_ **)** = **betaden(** _a_ **,** _b_ **,** _x_ **)** , but [**betaden()**](https://www.stata.com/help.cgi?betaden\\(\\)) is the preferred function to use for the central beta distribution. **nbetaden()** is computed using an algorithm described in [Johnson, Kotz, and Balakrishnan (1995)](https://www.stata.com/help.cgi?f_nbetaden#JKB1995). Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _np_ : 0 to 1,000 Domain _x_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _x_ _<_ 1 Range: 0 to 8e+307\n\n**_Reference_**\n\nJohnson, N. L., S. Kotz, and N. Balakrishnan. 1995. _Continuous_ _Univariate Distributions, Vol. 2_. 2nd ed. New York: Wiley.\n\n",
    "nbinomial": "**nbinomial(** _n_ **,** _k_ **,** _p_ **)** Description: the cumulative probability of the negative binomial distribution _n_ can be nonintegral. When _n_ is an integer, **nbinomial()** returns the probability of observing _k_ or fewer failures before the _n_ th success, when the probability of a success on one trial is _p_.\n\nThe negative binomial distribution function is evaluated using [**ibeta()**](https://www.stata.com/help.cgi?ibeta\\(\\)). Domain _n_ : 1e-10 to 1e+17 (can be nonintegral) Domain _k_ : 0 to 2^53-1 Domain _p_ : 0 to 1 (left exclusive) Range: 0 to 1\n\n",
    "nbinomialp": "**nbinomialp(** _n_ **,** _k_ **,** _p_ **)** Description: the negative binomial probability\n\nWhen _n_ is an integer, **nbinomialp()** returns the probability of observing exactly [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _k_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)) failures before the _n_ th success when the probability of a success on one trial is _p_. Domain _n_ : 1e-10 to 1e+6 (can be nonintegral) Domain _k_ : 0 to 1e+10 Domain _p_ : 0 to 1 (left exclusive) Range: 0 to 1\n\n",
    "nbinomialtail": "**nbinomialtail(** _n_ **,** _k_ **,** _p_ **)** Description: the reverse cumulative probability of the negative binomial distribution When _n_ is an integer, **nbinomialtail()** returns the probability of observing _k_ or more failures before the _n_ th success, when the probability of a success on one trial is _p_.\n\nThe reverse negative binomial distribution function is evaluated using [**ibetatail()**](https://www.stata.com/help.cgi?ibetatail\\(\\)). Domain _n_ : 1e-10 to 1e+17 (can be nonintegral) Domain _k_ : 0 to 2^53-1 Domain _p_ : 0 to 1 (left exclusive) Range: 0 to 1\n\n",
    "nchi2": "**nchi2(** _df_ **,** _np_ **,** _x_ **)** Description: the cumulative noncentral chi-squared distribution; **0** if _x_ < 0\n\n_df_ denotes the degrees of freedom, _np_ is the noncentrality parameter, and _x_ is the value of chi-squared.\n\n**nchi2(** _df_ **,0,** _x_ **)** = **chi2(** _df_ **,** _x_ **)** , but **chi2()** is the preferred function to use for the central chi-squared distribution. Domain _df_ : 2e-10 to 1e+6 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ 0 Range: 0 to 1\n\n",
    "nchi2den": "**nchi2den(** _df_ **,** _np_ **,** _x_ **)** Description: the probability density of the noncentral chi-squared distribution; **0** if _x_ <= 0 _df_ denotes the degrees of freedom, _np_ is the noncentrality parameter, and _x_ is the value of chi-squared.\n\n**nchi2den(** _df_ **,0,** _x_ **)** = **chi2den(** _df_ **,** _x_ **)** , but [**chi2den()**](https://www.stata.com/help.cgi?chi2den\\(\\)) is the preferred function to use for the central chi-squared distribution. Domain _df_ : 2e-10 to 1e+6 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 8e+307\n\n",
    "nchi2tail": "**nchi2tail(** _df_ **,** _np_ **,** _x_ **)** Description: the reverse cumulative (upper tail or survivor) noncentral chi-squared distribution; **1** if _x_ < 0 _df_ denotes the degrees of freedom, _np_ is the noncentrality parameter, and _x_ is the value of chi-squared. Domain _df_ : 2e-10 to 1e+6 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "nF": "**nF(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** Description: the cumulative noncentral F distribution with _df1_ numerator and _df2_ denominator degrees of freedom and noncentrality parameter _np_ ; **0** if _f_ < 0\n\n**nF(** _df1_ **,** _df2_ **,0,** _f_ **)** = **F(** _df1_ **,** _df2_ **,** _f_ **)**\n\n**nF()** is computed using [**nibeta()**](https://www.stata.com/help.cgi?nibeta\\(\\)) based on the relationship between the noncentral beta and noncentral F distributions: **nF(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** = **nibeta(** _df1_ /2 **,** _df2_ /2 **,** _np_ **,** _df1_ * _f_ /{( _df1_ * _f_ )+ _df2_ }} **)**.\n\nDomain _df1_ : 2e-10 to 1e+8 (may be nonintegral) Domain _df2_ : 2e-10 to 1e+8 (may be nonintegral) Domain _np_ : 0 to 10,000 Domain _f_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "nFden": "**nFden(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** Description: the probability density function of the noncentral F density with _df1_ numerator and _df2_ denominator degrees of freedom and noncentrality parameter _np_ ; **0** if _f_ < 0\n\n**nFden(** _df1_ **,** _df2_ **,0,** _f_ **)** = **Fden(** _df1_ **,** _df2_ **,** _f_ **)** , but [**Fden()**](https://www.stata.com/help.cgi?Fden\\(\\)) is the preferred function to use for the central F distribution.\n\nAlso, if _F_ follows the noncentral _F_ distribution with _df1_ and _df2_ degrees of freedom and noncentrality parameter _np_ , then\n\n_df1 F_ \\----------- _df2_ \\+ _df1 F_\n\nfollows a noncentral beta distribution with shape parameters _a_ = _df1_ /2, _b_ = _df2_ /2, and noncentrality parameter _np_ , as given in **nbetaden()**. **nFden()** is computed based on this relationship. Domain _df1_ : 1e-323 to 8e+307 (may be nonintegral) Domain _df2_ : 1e-323 to 8e+307 (may be nonintegral) Domain _np_ : 0 to 1,000 Domain _f_ : -8e+307 to 8e+307; interesting domain is _f_ _>_ 0 Range: 0 to 8e+307\n\n",
    "nFtail": "**nFtail(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** Description: the reverse cumulative (upper tail or survivor) noncentral F distribution with _df1_ numerator and _df2_ denominator degrees of freedom and noncentrality parameter _np_ ; **1** if _f_ < 0\n\n**nFtail()** is computed using **nibeta()** based on the relationship between the noncentral beta and F distributions. See [Johnson, Kotz, and Balakrishnan](https://www.stata.com/help.cgi?density+functions#JKB1995) [(1995)](https://www.stata.com/help.cgi?density+functions#JKB1995) for more details. Domain _df1_ : 1e-323 to 8e+307 (may be nonintegral) Domain _df2_ : 1e-323 to 8e+307 (may be nonintegral) Domain _np_ : 0 to 1,000 Domain _f_ : -8e+307 to 8e+307; interesting domain is _f_ _>_ 0 Range: 0 to 1\n\n**_Reference_**\n\nJohnson, N. L., S. Kotz, and N. Balakrishnan. 1995. _Continuous_ _Univariate Distributions, Vol. 2_. 2nd ed. New York: Wiley.\n\n",
    "nibeta": "**nibeta(** _a_ **,** _b_ **,** _np_ **,** _x_ **)** Description: the cumulative noncentral beta distribution; **0** if _x_ < 0; **1** if _x_ > 1\n\n_a_ and _b_ are shape parameters, _np_ is the noncentrality parameter, and _x_ is the value of a beta random variable.\n\n**nibeta(** _a_ **,** _b_ **,0,** _x_ **)** = **ibeta(** _a_ **,** _b_ **,** _x_ **)** , but [**ibeta()**](https://www.stata.com/help.cgi?ibeta\\(\\)) is the preferred function to use for the central beta distribution. **nibeta()** is computed using an algorithm described in [Johnson, Kotz, and Balakrishnan (1995)](https://www.stata.com/help.cgi?f_nibeta#JKB1995). Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _np_ : 0 to 10,000 Domain _x_ : -8e+307 to 8e+307; interesting domain is 0 _<_ _x_ _<_ 1 Range: 0 to 1\n\n**_Reference_**\n\nJohnson, N. L., S. Kotz, and N. Balakrishnan. 1995. _Continuous_ _Univariate Distributions, Vol. 2_. 2nd ed. New York: Wiley.\n\n",
    "normal": "**normal(** _z_ **)** Description: the cumulative standard normal distribution Domain: -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "normalden": "**normalden(** _z_ **)** Description: the standard normal density Domain: -8e+307 to 8e+307 Range: 0 to 0.39894 ...\n\n**normalden(** _x_ **,** _s_ **)** Description: the normal density with mean 0 and standard deviation _s_\n\n**normalden(** _x_ **,1)** = **normalden(** _x_ **)** and **normalden(** _x_ **,** _s_ **)** = **normalden(** _x_ / _s_ **)** / _s_ Domain _x_ : -8e+307 to 8e+307 Domain _s_ : 1e-308 to 8e+307 Range: 0 to 8e+307\n\n**normalden(** _x_ **,** _m_ **,** _s_ **)** Description: the normal density with mean _m_ and standard deviation _s_\n\n**normalden(** _x_ **,0,** _s_ **)** = **normalden(** _x_ **,** _s_ **)** and **normalden(** _x_ **,** _m_ **,** _s_ **)** = **normalden(** ( _x_ - _m_ )/ _s_ **)** / _s_ Domain _x_ : -8e+307 to 8e+307 Domain _m_ : -8e+307 to 8e+307 Domain _s_ : 1e-308 to 8e+307 Range: 0 to 8e+307\n\n",
    "npnchi2": "**npnchi2(** _df_ **,** _x_ **,** _p_ **)** Description: the noncentrality parameter, _np_ , for the noncentral chi-squared: if **nchi2(** _df_ **,** _np_ **,** _x_ **)** = _p_ , then **npnchi2(** _df_ **,** _x_ **,** _p_ **)** = _np_ Domain _df_ : 2e-10 to 1e+6 (may be nonintegral) Domain _x_ : 0 to 8e+307 Domain _p_ : 0 to 1 Range: 0 to 10,000\n\n",
    "npnF": "**npnF(** _df1_ **,** _df2_ **,** _f_ **,** _p_ **)** Description: the noncentrality parameter, _np_ , for the noncentral F: if **nF(** _df1_ **,** _df2_ **,** _np_ **,** _f_ **)** = _p_ , then **npnF(** _df1_ **,** _df2_ **,** _f_ **,** _p_ **)** = _np_ Domain _df1_ : 2e-10 to 1e+6 (may be nonintegral) Domain _df2_ : 2e-10 to 1e+6 (may be nonintegral) Domain _f_ : 0 to 8e+307 Domain _p_ : 0 to 1 Range: 0 to 10,000\n\n",
    "npnt": "**npnt(** _df_ **,** _t_ **,** _p_ **)** Description: the noncentrality parameter, _np_ , for the noncentral Student's t distribution: if **nt(** _df_ **,** _np_ **,** _t_ **)** = _p_ , then **npnt(** _df_ **,** _t_ **,** _p_ **)** = _np_ Domain _df_ : 1e-100 to 1e+8 (may be nonintegral) Domain _t_ : -8e+307 to 8e+307 Domain _p_ : 0 to 1 Range: -1,000 to 1,000\n\n",
    "nt": "**nt(** _df_ **,** _np_ **,** _t_ **)** Description: the cumulative noncentral Student's t distribution with _df_ degrees of freedom and noncentrality parameter _np_\n\n**nt(** _df_ **,0,** _t_ **)** = **t(** _df_ **,** _t_ **)** Domain _df_ : 1e-100 to 1e+10 (may be nonintegral) Domain _np_ : -1,000 to 1,000 Domain _t_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "ntden": "**ntden(** _df_ **,** _np_ **,** _t_ **)** Description: the probability density function of the noncentral Student's t distribution with _df_ degrees of freedom and noncentrality parameter _np_ Domain _df_ : 1e-100 to 1e+10 (may be nonintegral) Domain _np_ : -1,000 to 1,000 Domain _t_ : -8e+307 to 8e+307 Range: 0 to 0.39894 ...\n\n",
    "nttail": "**nttail(** _df_ **,** _np_ **,** _t_ **)** Description: the reverse cumulative (upper tail or survivor) noncentral Student's t distribution with _df_ degrees of freedom and noncentrality parameter _np_ Domain _df_ : 1e-100 to 1e+10 (may be nonintegral) Domain _np_ : -1,000 to 1,000 Domain _t_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "nullmat": "**nullmat(** _matname_ **)** Description: use with the row-join ( **,** ) and column-join ( **\\** ) operators Consider the following code fragment, which is an attempt to create the vector (1,2,3,4):\n\n**forvalues i = 1/4 {** **mat v = (v, `i')** **}**\n\nThe above program will not work because, the first time through the loop, **v** will not yet exist, and thus forming **(v, `i')** makes no sense. **nullmat()** relaxes that restriction:\n\n**forvalues i = 1/4 {** **mat v = (nullmat(v), `i')** **}**\n\nThe **nullmat()** function informs Stata that if **v** does not exist, the function row-join is to be generalized. Joining nothing with **`i'** results in **(`i')**. Thus the first time through the loop, **v** = (1) is formed. The second time through, **v** does exist, so **v** = (1,2) is formed, and so on.\n\n**nullmat()** can be used only with the **,** and **\\** operators. Domain: matrix names, existing and nonexisting Range: matrices including null if _matname_ does not exist\n\n",
    "plural": "**plural(** _n_ **,** _s_ **)** Description: the plural of _s_ if _n_ != +/-1\n\nThe plural is formed by adding \"s\" to _s_.\n\n**plural(1, \"horse\")** = **\"horse\"** **plural(2, \"horse\")** = **\"horses\"** Domain _n_ : real numbers Domain _s_ : strings Range: strings\n\n**plural(** _n_ **,** _s1_ **,** _s2_ **)** Description: the plural of _s1_ , as modified by or replaced with _s2_ , if _n_ != +/-1\n\nIf _s2_ begins with the character \" **+** \", the plural is formed by adding the remainder of _s2_ to _s1_. If _s2_ begins with the character \" **-** \", the plural is formed by subtracting the remainder of _s2_ from _s1_. If _s2_ begins with neither \" **+** \" nor \" **-** \", then the plural is formed by returning _s2_.\n\n**plural(2, \"glass\", \"+es\")** = **\"glasses\"** **plural(1, \"mouse\", \"mice\")** = **\"mouse\"** **plural(2, \"mouse\", \"mice\")** = **\"mice\"** **plural(2, \"abcdefg\", \"-efg\")** = **\"abcd\"** Domain _n_ : real numbers Domain _s1_ : strings Domain _s2_ : strings Range: strings\n\n",
    "poisson": "**poisson(** _m_ **,** _k_ **)** Description: the probability of observing **floor(** _k_ **)** or fewer outcomes that are distributed as Poisson with mean _m_\n\nThe Poisson distribution function is evaluated using [**gammaptail()**](https://www.stata.com/help.cgi?gammaptail\\(\\)). Domain _m_ : 1e-10 to 2^53-1 Domain _k_ : 0 to 2^53-1 Range: 0 to 1\n\n",
    "poissonp": "**poissonp(** _m_ **,** _k_ **)** Description: the probability of observing **floor(** _k_ **)** outcomes that are distributed as Poisson with mean _m_\n\nThe Poisson probability function is evaluated using [**gammaden()**](https://www.stata.com/help.cgi?gammaden\\(\\)). Domain _m_ : 1e-10 to 1e+8 Domain _k_ : 0 to 1e+9 Range: 0 to 1\n\n",
    "poissontail": "**poissontail(** _m_ **,** _k_ **)** Description: the probability of observing **floor(** _k_ **)** or more outcomes that are distributed as Poisson with mean _m_\n\nThe reverse cumulative Poisson distribution function is evaluated using [**gammap()**](https://www.stata.com/help.cgi?gammap\\(\\)). Domain _m_ : 1e-10 to 2^53-1 Domain _k_ : 0 to 2^53-1 Range: 0 to 1\n\n",
    "qofd": "**qofd(** _e_d_ **)** Description: the _e_q_ quarterly date (quarters since 1960q1) containing date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: **%tq** dates 0100q1 to 9999q4 (integers -7,440 to 32,159)\n\n",
    "quarter": "**quarter(** _e_d_ **)** Description: the numeric quarter of the year corresponding to date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 1 to 4 or _missing_\n\n",
    "quarterly": "**quarterly(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_q_ quarterly date (quarters since 1960q1) corresponding to _s1_ based on _s2_ and _Y_ ; _Y_ specifies _topyear_ ; see [**date()**](https://www.stata.com/help.cgi?date\\(\\)) Domain _s1_ : strings Domain _s2_ : strings **\"QY\"** and **\"YQ\"** ; **Y** may be prefixed with _##_ Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: **%tq** dates 0100q1 to 9999q4 (integers -7,440 to 32,159) or _missing_\n\n",
    "r": "**r(** _name_ **)** Description: the value of stored result **r(** _name_ **)** ; see **[U] 18.8** **Accessing results calculated by other programs**\n\n**r(** _name_ **)** = scalar missing if the stored result does not exist **r(** _name_ **)** = specified matrix if the stored result is a matrix **r(** _name_ **)** = scalar numeric value if the stored result is a scalar that can be interpreted as a number Domain: names Range: strings, scalars, matrices, or _missing_\n\n",
    "rbeta": "**rbeta(** _a_ **,** _b_ **)** Description: beta( _a_ , _b_ ) random variates, where _a_ and _b_ are the beta distribution shape parameters\n\nBesides using the standard methodology for generating random variates from a given distribution, **rbeta()** uses the specialized algorithms of Johnk ([Gentle 2003](https://www.stata.com/help.cgi?rbeta\\(\\)#G2003)), Atkinson and Wittaker ([1970](https://www.stata.com/help.cgi?rbeta\\(\\)#AW1970), [1976](https://www.stata.com/help.cgi?rbeta\\(\\)#AW1976)), [Devroye (1986)](https://www.stata.com/help.cgi?rbeta\\(\\)#D1986), and [Schmeiser and Babu (1980)](https://www.stata.com/help.cgi?rbeta\\(\\)#SB1980). Domain _a_ : 0.05 to 1e+5 Domain _b_ : 0.15 to 1e+5 Range: 0 to 1 (exclusive)\n\n**_References_**\n\nAtkinson, A. C., and J. Whittaker. 1976. A switching algorithm for the generation of beta random variables with at least one parameter less than 1. _Journal of the Royal Statistical Society, Series A_ 139: 462-467.\n\n\\------. 1970. Algorithm AS 134: The generation of beta random variables with one parameter greater than and one parameter less than 1. _Applied Statistics_ 28: 90-93.\n\nDevroye, L. 1986. _Non-uniform Random Variate Generation_. New York: Springer.\n\nGentle, J. E. 2003. _Random Number Generation and Monte Carlo Methods_. 2nd ed. New York: Springer.\n\nSchmeiser, B. W., and A. J. G. Babu. 1980. Beta variate generation via exponential majorizing functions. _Operations Research_ 28: 917-926.\n\n",
    "rbinomial": "**rbinomial(** _n_ **,** _p_ **)** Description: binomial( _n_ , _p_ ) random variates, where _n_ is the number of trials and _p_ is the success probability\n\nBesides using the standard methodology for generating random variates from a given distribution, **rbinomial()** uses the specialized algorithms of [Kachitvichyanukul](https://www.stata.com/help.cgi?rbinomial\\(\\)#K1982) [(1982)](https://www.stata.com/help.cgi?rbinomial\\(\\)#K1982), [Kachitvichyanukul and Schmeiser (1988)](https://www.stata.com/help.cgi?rbinomial\\(\\)#KS1988), and [Kemp](https://www.stata.com/help.cgi?rbinomial\\(\\)#K1986) [(1986)](https://www.stata.com/help.cgi?rbinomial\\(\\)#K1986). Domain _n_ : 1 to 1e+11 Domain _p_ : 1e-8 to 1-1e-8 Range: 0 to _n_\n\n**_References_**\n\nKachitvichyanukul, V. 1982. Computer Generation of Poisson, Binomial, and Hypergeometric Random Variables. PhD thesis, Purdue University.\n\nKachitvichyanukul, V., and B. Schmeiser. 1988. Binomial random variate generation. _Communications of the Association for Computing_ _Machinery_ 31: 216-222.\n\nKemp, C. D. 1986. A modal method for generating binomial variates. _Communications in Statistics: Theory and Methods_ 15: 805-813.\n\n",
    "rcauchy": "**rcauchy(** _a_ **,** _b_ **)** Description: Cauchy( _a_ , _b_ ) random variates, where _a_ is the location parameter and _b_ is the scale parameter Domain _a_ : -1e+300 to 1e+300 Domain _b_ : 1e-100 to 1e+300 Range: **c(mindouble)** to **c(maxdouble)**\n\n",
    "rchi2": "**rchi2(** _df_ **)** Description: chi-squared, with _df_ degrees of freedom, random variates Domain _df_ : 2e-4 to 2e+8 Range: 0 to **c(maxdouble)**\n\n",
    "real": "**real(** _s_ **)** Description: _s_ converted to numeric or _missing_\n\nAlso see [**strofreal()**](https://www.stata.com/help.cgi?strofreal\\(\\)).\n\n**real(\"5.2\")+1** = **6.2** **real(\"hello\")** = **.** Domain _s_ : strings Range: -8e+307 to 8e+307 or _missing_\n\n",
    "recode": "**recode(** _x_ **,** _x1_ **,** _x2_ **,** _..._ **,** _xn_ **)** Description: _missing_ if _x1_ , _x2_ , ..., _xn_ is not weakly increasing; _x_ if _x_ is missing; _x1_ if _x_ _<_ _x1_ ; _x2_ if _x_ _<_ _x2_ , ...; otherwise, _xn_ if _x_ > _x1_ , _x2_ , ..., _xn-1_. _xi_ _>_ **.** is interpreted as _xi_ = +inf\n\nAlso see [**autocode()**](https://www.stata.com/help.cgi?autocode\\(\\)) and [**irecode()**](https://www.stata.com/help.cgi?irecode\\(\\)) for other styles of recode functions. Domain _x_ : -8e+307 to 8e+307 or _missing_ Domain _x1_ : -8e+307 to 8e+307 Domain _x2_ : _x1_ to 8e+307 ... Domain _xn_ : _xn-1_ to 8e+307 Range: _x1_ , _x2_ , ..., _xn_ or _missing_\n\n",
    "regexm": "**regexm(** _s_ **,** _re_ **)** Description: performs a match of a regular expression and evaluates to **1** if regular expression _re_ is satisfied by the ASCII string _s_ ; otherwise, **0**\n\nRegular expression syntax is based on Henry Spencer's NFA algorithm, and this is nearly identical to the POSIX.2 standard. _s_ and _re_ may not contain binary 0 ( **\\0** ).\n\n**regexm()** is intended for use with only plain ASCII characters. For Unicode characters beyond the plain ASCII range, the match is based on bytes. For a character-based match, see [**ustrregexm()**](https://www.stata.com/help.cgi?f_ustrregexm). Domain _s_ : ASCII strings Domain _re_ : regular expression Range: ASCII strings\n\n",
    "regexr": "**regexr(** _s1_ **,** _re_ **,** _s2_ **)** Description: replaces the first substring within ASCII string _s1_ that matches _re_ with ASCII string _s2_ and returns the resulting string\n\nIf _s1_ contains no substring that matches _re_ , the unaltered _s1_ is returned. _s1_ and the result of **regexr()** may be at most 1,100,000 characters long. _s1_ , _re_ , and _s2_ may not contain binary 0 ( **\\0** ).\n\n**regexr()** is intended for use with only plain ASCII characters. For Unicode characters beyond the plain ASCII range, the match is based on bytes and the result is restricted to 1,100,000 bytes. For a character-based match, see [**ustrregexrf()**](https://www.stata.com/help.cgi?f_ustrregexrf) or [**ustrregexra()**](https://www.stata.com/help.cgi?f_ustrregexra). Domain _s1_ : ASCII strings Domain _re_ : regular expression Domain _s2_ : ASCII strings Range: ASCII strings\n\n",
    "regexs": "**regexs(** _n_ **)** Description: subexpression _n_ from a previous **regexm()** match, where 0 _<_ _n_ < 10\n\nSubexpression 0 is reserved for the entire string that satisfied the regular expression. The returned subexpression may be at most 1,100,000 characters (bytes) long. Domain _n_ : 0 to 9 Range: ASCII strings\n\n**_Examples_**\n\nSetup **. sysuse auto**\n\nList makes and models of cars whose make begin with the capital letter \"B\" **. generate bbegin = regexm(make, \"^B\")** **. list make if bbegin == 1**\n\nOr, all on one line **. list make if regexm(make, \"^B\") == 1**\n\nList makes and models of cars where the letters \"ck\" appear anywhere in the make or model **. list make if regexm(make, \"ck\") == 1**\n\nList makes and models of cars whose model ends with a digit **. list make if regexm(make, \"[0-9]$\") == 1**\n\nGenerate a new variable **make2** equal to **make** , then replace **make2** with **\"found\"** if **make2** begins with the capital letter \"B\" and ends with a three-digit number followed by a single lowercase letter **. generate make2 = make** **. replace make2 = regexr(make2, \"^B.*[0-9][0-9][0-9][a-z]$\",** **\"found\")** **. list make make2 if make != make2**\n\nConvert a phone number of the form (123) 456-7890 to the form 123-456-7890: **. clear** **. input str15 number**\n\nnumber 1\\. \"(123) 456-7890\" 2\\. \"(800) STATAPC\" 3\\. end\n\n**. gen str newnum = regexs(1) + \"-\" + regexs(2)** **if regexm(number,** **\"^\\\\(([0-9]+)\\\\) (.*)\")** **. list number newnum**\n\n",
    "reldif": "**reldif(** _x_ **,** _y_ **)** Description: the \"relative\" difference | _x_ - _y_ |/(| _y_ |+1); **0** if both arguments are the same type of extended missing value; _missing_ if only one argument is missing or if the two arguments are two different types of _missing_ Domain _x_ : -8e+307 to 8e+307 or _missing_ Domain _y_ : -8e+307 to 8e+307 or _missing_ Range: -8e+307 to 8e+307 or _missing_\n\n",
    "replay": "**replay()** Description: **1** if the first nonblank character of local macro **`0'** is a comma, or if **`0'** is empty\n\nThis is a function for use by programmers writing estimation commands; see [**[P] ereturn**](https://www.stata.com/help.cgi?ereturn). Range: integers 0 and 1, meaning _false_ and _true_ , respectively\n\n",
    "return": "**return(** _name_ **)** Description: the value of the to-be-stored result **return(** _name_ **)** ; see [**[P] return**](https://www.stata.com/help.cgi?return)\n\n**return(** _name_ **)** = scalar missing if the stored result does not exist **return(** _name_ **)** = specified matrix if the stored result is a matrix **return(** _name_ **)** = scalar numeric value if the stored result is a scalar Domain: names Range: strings, scalars, matrices, or _missing_\n\n",
    "rexponential": "**rexponential(** _b_ **)** Description: exponential random variates with scale _b_ Domain _b_ : 1e-323 to 8e+307 Range: 1e-323 to 8e+307\n\n",
    "rgamma": "**rgamma(** _a_ **,** _b_ **)** Description: gamma( _a_ , _b_ ) random variates, where _a_ is the gamma shape parameter and _b_ is the scale parameter\n\nMethods for generating gamma variates are taken from [Ahrens and Dieter (1974)](https://www.stata.com/help.cgi?rgamma\\(\\)#AD1974), [Best (1983)](https://www.stata.com/help.cgi?rgamma\\(\\)#B1983), and [Schmeiser and](https://www.stata.com/help.cgi?rgamma\\(\\)#SL1980) [Lal (1980)](https://www.stata.com/help.cgi?rgamma\\(\\)#SL1980). Domain _a_ : 1e-4 to 1e+8 Domain _b_ : **c(smallestdouble)** to **c(maxdouble)** Range: 0 to **c(maxdouble)**\n\n**_References_**\n\nAhrens, J. H., and U. Dieter. 1974. Computer methods for sampling from gamma, beta, Poisson, and binomial distributions. _Computing_ 12: 223-246.\n\nBest, D. J. 1983. A note on gamma variate generators with shape parameters less than unity. _Computing_ 30: 185-188.\n\nSchmeiser, B. W., and R. Lal. 1980. Squeeze methods for generating gamma variates. _Journal of the American Statistical Association_ 75: 679-682.\n\n",
    "rhypergeometric": "**rhypergeometric(** _N_ **,** _K_ **,** _n_ **)** Description: hypergeometric random variates\n\nThe distribution parameters are integer valued, where _N_ is the population size, _K_ is the number of elements in the population that have the attribute of interest, and _n_ is the sample size.\n\nBesides using the standard methodology for generating random variates from a given distribution, **rhypergeometric()** uses the specialized algorithms of [Kachitvichyanukul (1982)](https://www.stata.com/help.cgi?rhypergeometric\\(\\)#K1982) and [Kachitvichyanukul and](https://www.stata.com/help.cgi?rhypergeometric\\(\\)#KS1985) [Schmeiser (1985)](https://www.stata.com/help.cgi?rhypergeometric\\(\\)#KS1985). Domain _N_ : 2 to 1e+6 Domain _K_ : 1 to _N-1_ Domain _n_ : 1 to _N-1_ Range: **max(** 0 **,** _n-N+K_ **)** to **min(** _K,n_ **)**\n\n**_References_**\n\nKachitvichyanukul, V. 1982. Computer Generation of Poisson, Binomial, and Hypergeometric Random Variables. PhD thesis, Purdue University.\n\nKachitvichyanukul, V., and B. Schmeiser. 1985. Computer generation of hypergeometric random variates. _Journal of Statistical Computation_ _and Simulation_ 22: 127-145.\n\n",
    "rigaussian": "**rigaussian(** _m_ **,** _a_ **)** Description: inverse Gaussian random variates with mean _m_ and shape parameter _a_\n\n**rigaussian()** is based on a method proposed by [Michael,](https://www.stata.com/help.cgi?rigaussian\\(\\)#MSH1976) [Schucany, and Haas (1976)](https://www.stata.com/help.cgi?rigaussian\\(\\)#MSH1976). Domain _m_ : 1e-10 to 1000 Domain _a_ : 0.001 to 1e+10 Range: 0 to **c(maxdouble)**\n\n**_Reference_**\n\nMichael, J. R., W. R. Schucany, and R. W. Haas. 1976. Generating random variates using transformations with multiple roots. _American_ _Statistician_ 30: 88-90.\n\n",
    "rlaplace": "**rlaplace(** _m_ **,** _b_ **)** Description: Laplace( _m_ , _b_ ) random variates with mean _m_ and scale parameter _b_ Domain _m_ : -1e+300 to 1e+300 Domain _b_ : 1e-300 to 1e+300 Range: **c(mindouble)** to **c(maxdouble)**\n\n",
    "rlogistic": "**rlogistic()** Description: logistic variates with mean 0 and standard deviation pi/sqrt(3)\n\nThe variates _x_ are generated by _x_ = **invlogistic(0,1,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Range: **c(mindouble)** to **c(maxdouble)**\n\n**rlogistic(** _s_ **)** Description: logistic variates with mean 0, scale _s_ , and standard deviation _s_ *pi/sqrt(3)\n\nThe variates _x_ are generated by _x_ = **invlogistic(0,** _s_ **,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Domain _s_ : 0 to **c(maxdouble)** Range: **c(mindouble)** to **c(maxdouble)**\n\n**rlogistic(** _m_ **,** _s_ **)** Description: logistic variates with mean _m_ , scale _s_ , and standard deviation _s_ *pi/sqrt(3)\n\nThe variates _x_ are generated by _x_ = **invlogistic(** _m_ **,** _s_ **,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Domain _m_ : **c(mindouble)** to **c(maxdouble)** Domain _s_ : 0 to **c(maxdouble)** Range: **c(mindouble)** to **c(maxdouble)**\n\n",
    "rnbinomial": "**rnbinomial(** _n_ **,** _p_ **)** Description: negative binomial random variates\n\nIf _n_ is integer valued, **rnbinomial()** returns the number of failures before the _n_ th success, where the probability of success on a single trial is _p_. _n_ can also be nonintegral. Domain _n_ : 1e-4 to 1e+5 Domain _p_ : 1e-4 to 1-1e-4 Range: 0 to 2^53-1\n\n",
    "rnormal": "**rnormal()** Description: standard normal (Gaussian) random variates, that is, variates from a normal distribution with a mean of 0 and a standard deviation of 1 Range: **c(mindouble)** to **c(maxdouble)**\n\n**rnormal(** _m_ **)** Description: normal( _m_ ,1) (Gaussian) random variates, where _m_ is the mean and the standard deviation is 1 Domain _m_ : **c(mindouble)** to **c(maxdouble)** Range: **c(mindouble)** to **c(maxdouble)**\n\n**rnormal(** _m_ **,** _s_ **)** Description: normal( _m_ , _s_ ) (Gaussian) random variates, where _m_ is the mean and _s_ is the standard deviation\n\nThe methods for generating normal (Gaussian) random variates are taken from [Knuth (1998, 122-128)](https://www.stata.com/help.cgi?rnormal\\(\\)#K1998); [Marsaglia, MacLaren, and Bray (1964)](https://www.stata.com/help.cgi?rnormal\\(\\)#MMB1964); and [Walker (1977)](https://www.stata.com/help.cgi?rnormal\\(\\)#W1977). Domain _m_ : **c(mindouble)** to **c(maxdouble)** Domain _s_ : 0 to **c(maxdouble)** Range: **c(mindouble)** to **c(maxdouble)**\n\n**_References_**\n\nKnuth, D. 1998. _The Art of Computer Programming, Volume 2:_ _Seminumerical Algorithms_. 3rd ed. Reading, MA: Addison Wesley.\n\nMarsaglia, G., M. D. MacLaren, and T. A. Bray. 1964. A fast procedure for generating normal random variables. _Communications of the ACM_ 7: 4-10.\n\nWalker, A. J. 1977. An efficient method for generating discrete random variables with general distributions. _ACM Transactions on_ _Mathematical Software_ 3: 253-256.\n\n",
    "round": "**round(** _x_ **,** _y_ **)** or **round(** _x_ **)** Description: _x_ rounded in units of _y_ or _x_ rounded to the nearest integer if the argument _y_ is omitted; _x_ (not \" **.** \") if _x_ is missing (meaning that **round(.a)** = **.a** and that **round(.a,** _y_ **)** = **.a** if _y_ is not missing) and if _y_ is missing, then \" **.** \" is returned\n\nFor _y_ = 1, or with _y_ omitted, this amounts to the closest integer to _x_ ; **round(5.2,1)** is 5, as is **round(4.8,1)** ; **round(-5.2,1)** is -5, as is **round(-4.8,1)**. The rounding definition is generalized for _y_ != 1. With _y_ = 0.01, for instance, _x_ is rounded to two decimal places; **round(sqrt(2),.01)** is 1.41. _y_ may also be larger than 1; **round(28,5)** is 30, which is 28 rounded to the closest multiple of 5. For _y_ = 0, the function is defined as returning _x_ unmodified. Also see [**int(**](https://www.stata.com/help.cgi?int\\(\\))[ _x_](https://www.stata.com/help.cgi?int\\(\\))[ **)**](https://www.stata.com/help.cgi?int\\(\\)), [**ceil(**](https://www.stata.com/help.cgi?ceil\\(\\))[ _x_](https://www.stata.com/help.cgi?ceil\\(\\))[ **)**](https://www.stata.com/help.cgi?ceil\\(\\)), and [**floor(**](https://www.stata.com/help.cgi?floor\\(\\))[ _x_](https://www.stata.com/help.cgi?floor\\(\\))[ **)**](https://www.stata.com/help.cgi?floor\\(\\)). Domain _x_ : -8e+307 to 8e+307 Domain _y_ : -8e+307 to 8e+307 Range: -8e+307 to 8e+307\n\n",
    "roweqnumb": "**roweqnumb(** _M_ **,** _s_ **)** Description: the equation number of _M_ associated with row equation _s_ ; _missing_ if the row equation cannot be found Domain _M_ : matrices Domain _s_ : strings Range: integer scalars 1 to **matsize** or _missing_\n\n",
    "rownfreeparms": "**rownfreeparms(** _M_ **)** Description: the number of free parameters in rows of _M_ Domain _M_ : matrices Range: integer scalars 0 to **matsize**\n\n",
    "rownumb": "**rownumb(** _M_ **,** _s_ **)** Description: the row number of _M_ associated with row name _s_ ; _missing_ if the row cannot be found Domain _M_ : matrices Domain _s_ : strings Range: integer scalars 1 to **matsize** or _missing_\n\n",
    "rowsof": "**rowsof(** _M_ **)** Description: the number of rows of _M_ Domain: matrices Range: integer scalars 1 to **matsize**\n\n",
    "rpoisson": "**rpoisson(** _m_ **)** Description: Poisson( _m_ ) random variates, where _m_ is the distribution mean\n\nPoisson variates are generated using the probability integral transform methods of Kemp and Kemp ([1990](https://www.stata.com/help.cgi?rpoisson\\(\\)#KK1990), [1991](https://www.stata.com/help.cgi?rpoisson\\(\\)#KK1991)) and the method of [Kachitvichyanukul (1982)](https://www.stata.com/help.cgi?rpoisson\\(\\)#K1982). Domain _m_ : 1e-6 to 1e+11 Range: 0 to 2^53-1\n\n**_References_**\n\nKachitvichyanukul, V. 1982. Computer Generation of Poisson, Binomial, and Hypergeometric Random Variables. PhD thesis, Purdue University.\n\nKemp, A. W., and C. D. Kemp. 1990. A composition-search algorithm for low- parameter Poisson generation. _Journal of Statistical Computation_ _and Simulation_ 35: 239-244.\n\nKemp, C. D., and A. W. Kemp. 1991. Poisson random variate generation. _Applied Statistics_ 40: 143-158.\n\n",
    "rt": "**rt(** _df_ **)** Description: Student's t random variates, where _df_ is the degrees of freedom\n\nStudent's t variates are generated using the method of Kinderman and Monahan ([1977](https://www.stata.com/help.cgi?rt\\(\\)#KM1977), [1980](https://www.stata.com/help.cgi?rt\\(\\)#KM1980)). Domain _df_ : 1 to 2^53-1 Range: **c(mindouble)** to **c(maxdouble)**\n\n**_References_**\n\nKinderman, A. J., and J. F. Monahan. 1977. Computer generation of random variables using the ratio of uniform deviates. _Association_ _for Computing Machinery Transactions on Mathematical Software_ 3: 257-260.\n\n\\------. 1980. New methods for generating Student's t and gamma variables. _Computing_ 25: 369-377.\n\n",
    "runiform": "**runiform()** Description: uniformly distributed random variates over the interval (0,1)\n\n**runiform()** can be seeded with the **set seed** command; see [**[R] set seed**](https://www.stata.com/help.cgi?set_seed). Range: **c(epsdouble)** to 1- **c(epsdouble)**\n\n**runiform(** _a_ **,** _b_ **)** Description: uniformly distributed random variates over the interval ( _a_ , _b_ ) Domain _a_ : **c(mindouble)** to **c(maxdouble)** Domain _b_ : **c(mindouble)** to **c(maxdouble)** Range: _a_ + **c(epsdouble)** to _b_ - **c(epsdouble)**\n\n",
    "runiformint": "**runiformint(** _a_ **,** _b_ **)** Description: uniformly distributed random integer variates on the interval [ _a_ , _b_ ]\n\nIf _a_ or _b_ is nonintegral, **runiformint(** _a_ **,** _b_ **)** returns **runiformint(floor(** _a_ **), floor(** _b_ **))**. Domain _a_ : -2^53 to 2^53 (may be nonintegral) Domain _b_ : -2^53 to 2^53 (may be nonintegral) Range: -2^53 to 2^53\n\n",
    "rweibull": "**rweibull(** _a_ **,** _b_ **)** Description: Weibull variates with shape _a_ and scale _b_\n\nThe variates _x_ are generated by _x_ = **invweibulltail(** _a_ **,** _b_ **,0,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Domain _a_ : 0.01 to 1e+6 Domain _b_ : 1e-323 to 8e+307 Range: 1e-323 to 8e+307\n\n**rweibull(** _a_ **,** _b_ **,** _g_ **)** Description: Weibull variates with shape _a_ , scale _b_ , and location _g_\n\nThe variates _x_ are generated by _x_ = **invweibulltail(** _a_ **,** _b_ **,** _g_ **,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Domain _a_ : 0.01 to 1e+6 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e-307 to 8e+307 Range: _g_ + **c(epsdouble)** to 8e+307\n\n",
    "rweibullph": "**rweibullph(** _a_ **,** _b_ **)** Description: Weibull (proportional hazards) variates with shape _a_ and scale _b_\n\nThe variates _x_ are generated by _x_ = **invweibullphtail(** _a_ **,** _b_ **,0,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Domain _a_ : 0.01 to 1e+6 Domain _b_ : 1e-323 to 8e+307 Range: 1e-323 to 8e+307\n\n**rweibullph(** _a_ **,** _b_ **,** _g_ **)** Description: Weibull (proportional hazards) variates with shape _a_ , scale _b_ , and location _g_\n\nThe variates _x_ are generated by _x_ = **invweibullphtail(** _a_ **,** _b_ **,** _g_ **,** _u_ **)** , where _u_ is a random uniform(0,1) variate. Domain _a_ : 0.01 to 1e+6 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e-307 to 8e+307 Range: _g_ + **c(epsdouble)** to 8e+307\n\n",
    "s": "**s(** _name_ **)** Description: the value of stored result **s(** _name_ **)** ; see **[U] 18.8** **Accessing results calculated by other programs**\n\n**s(** _name_ **)** = **.** if the stored result does not exist Domain: names Range: strings or _missing_\n\n",
    "scalar": "**scalar(** _exp_ **)** Description: restricts name interpretation to scalars and matrices\n\nNames in expressions can refer to names of variables in the dataset, names of matrices, or names of scalars. Matrices and scalars can have the same names as variables in the dataset. If names conflict, Stata assumes that you are referring to the name of the variable in the dataset.\n\n[**matrix()**](https://www.stata.com/help.cgi?matrix\\(\\)) and **scalar()** explicitly state that you are referring to matrices and scalars. **matrix()** and **scalar()** are the same function; scalars and matrices may not have the same names and so cannot be confused. Typing **scalar(x)** makes it clear that you are referring to the scalar or matrix named **x** and not the variable named **x** , should there happen to be a variable of that name. Domain: any valid expression Range: evaluation of _exp_\n\n",
    "seconds": "**seconds(** _ms_ **)** Description: _ms_ /1,000 Domain _ms_ : real; milliseconds Range: real or _missing_\n\n",
    "sign": "**sign(** _x_ **)** Description: the sign of _x_ : -1 if _x_ < 0, 0 if _x_ = 0, 1 if _x_ > 0, or _missing_ if _x_ is missing Domain: -8e+307 to 8e+307 or _missing_ Range: -1, 0, 1 or _missing_\n\n",
    "sin": "**sin(** _x_ **)** Description: the sine of _x_ , where _x_ is in radians Domain: -1e+18 to 1e+18 Range: -1 to 1\n\n",
    "sinh": "**sinh(** _x_ **)** Description: the hyperbolic sine of _x_ , **sinh(** _x_ **)** = {exp( _x_ ) - exp(- _x_ )}/2 Domain: -709 to 709 Range: -4.11e+307 to 4.11e+307\n\n",
    "smallestdouble": "**smallestdouble()** Description: the smallest double-precision number greater than zero If 0  < _d_ < **smallestdouble()** , then _d_ does not have full double precision; these are called the denormalized numbers. This function takes no arguments, but the parentheses must be included. Range: a double- precision number close to 0\n\n",
    "soundex": "**soundex(** _s_ **)** Description: the soundex code for a string, _s_\n\nThe soundex code consists of a letter followed by three numbers: the letter is the first ASCII letter of the name and the numbers encode the remaining consonants. Similar sounding consonants are encoded by the same number. Unicode characters beyond the plain ASCII range are ignored.\n\n**soundex(\"Ashcraft\")** = **\"A226\"** **soundex(\"Robert\")** = **\"R163\"** **soundex(\"Rupert\")** = **\"R163\"** Domain _s_ : strings Range: strings\n\n**soundex_nara(** _s_ **)** Description: the U.S. Census soundex code for a string, _s_\n\nThe soundex code consists of a letter followed by three numbers: the letter is the first ASCII letter of the name and the numbers encode the remaining consonants. Similar sounding consonants are encoded by the same number. Unicode characters beyond the plain ASCII range are ignored.\n\n**soundex_nara(\"Ashcraft\")** = **\"A261\"** Domain _s_ : strings Range: strings\n\n",
    "sqrt": "**sqrt(** _x_ **)** Description: the square root of _x_ Domain: 0 to 8e+307 Range: 0 to 1e+154\n\n",
    "ss": "**ss(** _e_tc_ **)** Description: the second corresponding to datetime _e_tc_ (ms. since 01jan1960 00:00:00.000) Domain _e_tc_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999) Range: real 0.000 through 59.999, _missing_\n\n",
    "ssC": "**ssC(** _e_tC_ **)** Description: the second corresponding to datetime _e_tC_ (ms. with leap seconds since 01jan1960 00:00:00.000) Domain _e_tC_ : datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999) Range: real 0.000 through 60.999, _missing_\n\n",
    "strcat": "**strcat(** _s1_ **,** _s2_ **)** Description: there is no **strcat()** function; instead the addition operator is used to concatenate strings\n\n**\"hello \" + \"world\"** = **\"hello world\"** **\"a\" + \"b\"** = **\"ab\"** **\"Caf\u00e9 \" + \"de Flore\"** = **\"Caf\u00e9 de Flore\"** Domain _s1_ : strings Domain _s2_ : strings Range: strings\n\n",
    "strdup": "**strdup(** _s1_ **,** _n_ **)** Description: there is no **strdup()** function; instead the multiplication operator is used to create multiple copies of strings\n\n**\"hello\" * 3** = **\"hellohellohello\"** **3 * \"hello\"** = **\"hellohellohello\"** **0 * \"hello\"** = **\"\"** **\"hello\" * 1** = **\"hello\"** **\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \" * 2** = **\"\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439\u0442\u0435 \"** Domain _s1_ : strings Domain _n_ : nonnegative integers 0, 1, 2, ... Range: strings\n\n",
    "strofreal": "**strofreal(** _n_ **,** _s_ **)** Description: _n_ converted to a string using the specified display format\n\nAlso see [**real()**](https://www.stata.com/help.cgi?real\\(\\)).\n\n**strofreal(4,\"%9.2f\")** = **\"4.00\"** **strofreal(123456789,\"%11.0g\")** = **\"123456789\"** **strofreal(123456789,\"%13.0gc\")** = **\"123,456,789\"** **strofreal(0,\"%td\")** = **\"01jan1960\"** **strofreal(225,\"%tq\")** = **\"2016q2\"** **strofreal(225,\"not a format\")** = **\"\"** Domain _n_ : -8e+307 to 8e+307 or _missing_ Domain _s_ : strings containing **%** _fmt_ numeric display format Range: strings\n\n",
    "string": "**string(** _n_ **,** _s_ **)** Description: a synonym for **strofreal(** _n_ **,** _s_ **)**\n\n",
    "strtrim": "**strtrim(** _s_ **)** Description: _s_ without leading and trailing blanks (ASCII space character **char(32)** ); equivalent to **strltrim(strrtrim(** _s_ **))**\n\n**strtrim(\" this \")** = **\"this\"** Domain _s_ : strings Range: strings without leading or trailing blanks\n\n",
    "stritrim": "**stritrim(** _s_ **)** Description: _s_ with multiple, consecutive internal blanks (ASCII space character **char(32)** ) collapsed to one blank\n\n**stritrim(\"hello** **there\")** = **\"hello there\"** Domain _s_ : strings Range: strings with no multiple, consecutive internal blanks\n\n",
    "strltrim": "**strltrim(** _s_ **)** Description: _s_ without leading blanks (ASCII space character **char(32)** )\n\n**strltrim(\" this\")** = **\"this\"** Domain _s_ : strings Range: strings without leading blanks\n\n",
    "strrtrim": "**strrtrim(** _s_ **)** Description: _s_ without trailing blanks (ASCII space character **char(32)** )\n\n**strrtrim(\"this \")** = **\"this\"** Domain _s_ : strings Range: strings without trailing blanks\n\n**_Remarks_**\n\nUse functions [**ustrtrim()**](https://www.stata.com/help.cgi?ustrtrim\\(\\)), [**ustrltrim()**](https://www.stata.com/help.cgi?ustrltrim\\(\\)), and [**ustrrtrim()**](https://www.stata.com/help.cgi?ustrrtrim\\(\\)) to remove Unicode whitespace and blank characters.\n\n",
    "strlen": "**strlen(** _s_ **)** Description: the number of characters in ASCII _s_ or length in bytes\n\n**strlen()** is intended for use with only plain ASCII characters and for use by programmers who want to obtain the byte-length of a string. Note that any Unicode character beyond ASCII range (code point greater than 127) takes more than 1 byte in the UTF-8 encoding; for example, **\u00e9** takes 2 bytes.\n\nFor the number of characters in a Unicode string, see [**ustrlen()**](https://www.stata.com/help.cgi?f_ustrlen).\n\n**strlen(\"ab\")** = **2** **strlen(\"\u00e9\")** = **2** Domain _s_ : strings Range: integers _>_ 0\n\n",
    "strupper": "**strupper(** _s_ **)** Description: uppercase ASCII characters in string _s_\n\nUnicode characters beyond the plain ASCII range are ignored.\n\n**strupper(\"this\")** = **\"THIS\"** **strupper(\"caf\u00e9\")** = **\"CAF\u00e9\"** Domain _s_ : strings Range: strings with uppercased characters\n\n",
    "strlower": "**strlower(** _s_ **)** Description: lowercase ASCII characters in string _s_\n\nUnicode characters beyond the plain ASCII range are ignored.\n\n**strlower(\"THIS\")** = **\"this\"** **strlower(\"CAF\u00c9\")** = **\"caf\u00c9\"** Domain _s_ : strings Range: strings with lowercased characters\n\n",
    "strproper": "**strproper(** _s_ **)** Description: a string with the first ASCII letter and any other letters immediately following characters that are not letters capitalized; all other ASCII letters converted to lowercase\n\n**strproper()** implements a form of titlecasing and is intended for use with only plain ASCII strings. Unicode characters beyond ASCII are treated as characters that are not letters. To titlecase strings with Unicode characters beyond the plain ASCII range or to implement language-sensitive rules for titlecasing, see [**ustrtitle()**](https://www.stata.com/help.cgi?f_ustrtitle).\n\n**strproper(\"mR. joHn a. sMitH\")** = **\"Mr. John A. Smith\"** **strproper(\"jack o'reilly\")** = **\"Jack O'Reilly\"** **strproper(\"2-cent's worth\")** = **\"2-Cent'S Worth\"** **strproper(\"vous \u00eates\")** = **\"Vous \u00eaTes\"** Domain _s_ : strings Range: strings\n\n**_Remarks_**\n\nUse functions [**ustrupper()**](https://www.stata.com/help.cgi?ustrupper\\(\\)) and [**ustrlower()**](https://www.stata.com/help.cgi?ustrlower\\(\\)) to convert Unicode characters in a string to uppercase and lowercase.\n\n",
    "strmatch": "**strmatch(** _s1_ **,** _s2_ **)** Description: **1** if _s1_ matches the pattern _s2_ ; otherwise, **0**\n\n**strmatch(\"17.4\",\"1??4\")** returns **1**. In _s2_ , **\"?\"** means that one character goes here, and **\"*\"** means that zero or more bytes go here. Note that a Unicode character may contain multiple bytes; thus, using **\"*\"** with Unicode characters can infrequently result in matches that do not occur at a character boundary.\n\nAlso see [**regexm()**](https://www.stata.com/help.cgi?regexm\\(\\)), **regexr()** , and **regexs()**.\n\n**strmatch(\"caf\u00c3\u00a9\", \"caf?\")** = **1** Domain _s1_ : strings Domain _s2_ : strings Range: integers 0 or 1\n\n",
    "strpos": "**strpos(** _s1_ **,** _s2_ **)** Description: the position in _s1_ at which _s2_ is first found; otherwise, **0** **strpos()** is intended for use with only plain ASCII characters and for use by programmers who want to obtain the byte-position of _s2_. Note that any Unicode character beyond ASCII range (code point greater than 127) takes more than 1 byte in the UTF-8 encoding; for example, **\u00e9** takes 2 bytes.\n\nTo find the character position of _s2_ in a Unicode string, see [**ustrpos()**](https://www.stata.com/help.cgi?f_ustrpos).\n\n**strpos(\"this\",\"is\")** = **3** **strpos(\"this\",\"it\")** = **0** Domain _s1_ : strings (to be searched) Domain _s2_ : strings (to search for) Range: integers _>_ 0\n\n",
    "strrpos": "**strrpos(** _s1_ **,** _s2_ **)** Description: the position in _s1_ at which _s2_ is last found; otherwise, **0** **strrpos()** is intended for use with only plain ASCII characters and for use by programmers who want to obtain the last byte-position of _s2_. Note that any Unicode character beyond ASCII range (code point greater than 127) takes more than 1 byte in the UTF-8 encoding; for example, **\u00e9** takes 2 bytes.\n\nTo find the last character position of _s2_ in a Unicode string, see [**ustrrpos()**](https://www.stata.com/help.cgi?f_ustrrpos).\n\n**strrpos(\"this\",\"is\")** = **3** **strrpos(\"this is\",\"is\")** = **6** **strrpos(\"this is\",\"it\")** = **0** Domain _s1_ : strings (to be searched) Domain _s2_ : strings (to search for) Range: integers _>_ 0\n\n**_Remarks_**\n\nUse functions [**ustrpos()**](https://www.stata.com/help.cgi?ustrpos\\(\\)) and [**ustrrpos()**](https://www.stata.com/help.cgi?ustrrpos\\(\\)) to search based on characters rather than on bytes.\n\n",
    "strreverse": "**strreverse(** _s_ **)** Description: reverses the ASCII string _s_\n\n**strreverse()** is intended for use with only plain ASCII characters. For Unicode characters beyond ASCII range (code point greater than 127), the encoded bytes are reversed.\n\nTo reverse the characters of Unicode string, see [**ustrreverse()**](https://www.stata.com/help.cgi?f_ustrreverse).\n\n**strreverse(\"hello\")** = **\"olleh\"** Domain _s_ : ASCII strings Range: ASCII reversed strings\n\n",
    "strtoname": "**strtoname(** _s_ [ **,** _p_ ] **)** Description: _s_ translated into a Stata 13 compatible name\n\n**strtoname()** results in a name that is truncated to 32 bytes. Each character in _s_ that is not allowed in a Stata name is converted to an underscore character, **_**. If the first character in _s_ is a numeric character and _p_ is not 0, then the result is prefixed with an underscore. Stata 14 names may be 32 characters; see **[U] 11.3 Naming conventions**.\n\n**strtoname(\"name\")** = **\"name\"** **strtoname(\"a name\")** = **\"a_name\"** **strtoname(\"5\",1)** = **\"_5\"** **strtoname(\"5:30\",1)** = **\"_5_30\"** **strtoname(\"5\",0)** = **\"5\"** **strtoname(\"5:30\",0)** = **\"5_30\"** Domain _s_ : strings Domain _p_ : integers 0 or 1 Range: strings\n\n",
    "subinstr": "**subinstr(** _s1_ **,** _s2_ **,** _s3_ **,** _n_ **)** Description: _s1_ , where the first _n_ occurrences in _s1_ of _s2_ have been replaced with _s3_ **subinstr()** is intended for use with only plain ASCII characters and for use by programmers who want to perform byte-based substitution. Note that any Unicode character beyond ASCII range (code point greater than 127) takes more than 1 byte in the UTF-8 encoding; for example, **\u00c3\u00a9** takes 2 bytes.\n\nTo perform character-based replacement in Unicode strings, see [**usubinstr()**](https://www.stata.com/help.cgi?f_usubinstr).\n\nIf _n_ is _missing_ , all occurrences are replaced.\n\nAlso see [**regexm()**](https://www.stata.com/help.cgi?regexm\\(\\)), **regexr()** , and **regexs()**.\n\n**subinstr(\"this is the day\",\"is\",\"X\",1)** = **\"thX is the** **day\"** **subinstr(\"this is the hour\",\"is\",\"X\",2)** = **\"thX X the** **hour\"** **subinstr(\"this is this\",\"is\",\"X\",.)** = **\"thX X thX\"** Domain _s1_ : strings (to be substituted into) Domain _s2_ : strings (to be substituted from) Domain _s3_ : strings (to be substituted with) Domain _n_ : integers _>_ 0 or _missing_ Range: strings\n\n",
    "subinword": "**subinword(** _s1_ **,** _s2_ **,** _s3_ **,** _n_ **)** Description: _s1_ , where the first _n_ occurrences in _s1_ of _s2_ as a word have been replaced with _s3_\n\nA word is defined as a space-separated token. A token at the beginning or end of _s1_ is considered space-separated. This is different from Unicode word, which is a language unit based on either a set of word-boundary rules or dictionaries for several languages (Chinese, Japanese, and Thai). If _n_ is _missing_ , all occurrences are replaced. Also see [**regexm()**](https://www.stata.com/help.cgi?regexm\\(\\)), **regexr()** , and **regexs()**.\n\n**subinword(\"this is the day\",\"is\",\"X\",1)** = **\"this X the** **day\"** **subinword(\"this is the hour\",\"is\",\"X\",.)** = **\"this X the** **hour\"** **subinword(\"this is this\",\"th\",\"X\",.)** = **\"this is this\"** Domain _s1_ : strings (to be substituted for) Domain _s2_ : strings (to be substituted from) Domain _s3_ : strings (to be substituted with) Domain _n_ : integers _>_ 0 or _missing_ Range: strings\n\n**_Remarks_**\n\nUse function [**usubinstr()**](https://www.stata.com/help.cgi?usubinstr\\(\\)) if your string contains Unicode characters.\n\n",
    "substr": "**substr(** _s_ **,** _n1_ **,** _n2_ **)** Description: the substring of _s_ , starting at _n1_ , for a length of _n2_ **substr()** is intended for use with only plain ASCII characters and for use by programmers who want to extract a subset of bytes from a string. For those with plain ASCII text, _n1_ is the starting character, and _n2_ is the length of the string in characters. For programmers, **substr()** is technically a byte-based function. For plain ASCII characters, the two are equivalent but you can operate on byte values beyond that range. Note that any Unicode character beyond ASCII range (code point greater than 127) takes more than 1 byte in the UTF-8 encoding; for example, **\u00c3\u00a9** takes 2 bytes.\n\nTo obtain substrings of Unicode strings, see [**usubstr()**](https://www.stata.com/help.cgi?f_usubstr).\n\nIf _n1_ < 0, _n1_ is interpreted as the distance from the end of the string; if _n2_ = **.** ( _missing_ ), the remaining portion of the string is returned.\n\n**substr(\"abcdef\",2,3)** = **\"bcd\"** **substr(\"abcdef\",-3,2)** = **\"de\"** **substr(\"abcdef\",2,.)** = **\"bcdef\"** **substr(\"abcdef\",-3,.)** = **\"def\"** **substr(\"abcdef\",2,0)** = **\"\"** **substr(\"abcdef\",15,2)** = **\"\"** Domain _s_ : strings Domain _n1_ : integers >= 1 and <= -1 Domain _n2_ : integers >= 1 Range: strings\n\n**_Remarks_**\n\nIf your string contains Unicode characters, see [**usubstr()**](https://www.stata.com/help.cgi?usubstr\\(\\)) and [**udsubstr()**](https://www.stata.com/help.cgi?udsubstr\\(\\)).\n\n",
    "sum": "**sum(** _x_ **)** Description: the running sum of _x_ , treating missing values as zero For example, following the command **generate y=sum(x)** , the _j_ th observation on **y** contains the sum of the first through _j_ th observations on **x**. See [**[D] egen**](https://www.stata.com/help.cgi?egen) for an alternative sum function, [**total()**](https://www.stata.com/help.cgi?egen#total\\(\\)), that produces a constant equal to the overall sum. Domain: all real numbers or _missing_ Range: -8e+307 to 8e+307 (excluding _missing_ )\n\n",
    "sweep": "**sweep(** _M_ **,** _i_ **)** Description: matrix _M_ with _i_ th row/column swept\n\nThe row and column names of the resultant matrix are obtained from _M_ , except that the _n_ th row and column names are interchanged. Domain _M_ : _n_ x _n_ matrices Domain _i_ : integer scalars 1 to _n_ Range: _n_ x _n_ matrices\n\n",
    "t": "**t(** _df_ **,** _t_ **)** Description: the cumulative Student's t distribution with _df_ degrees of freedom Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _t_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "tan": "**tan(** _x_ **)** Description: the tangent of _x_ , where _x_ is in radians Domain: -1e+18 to 1e+18 Range: -1e+17 to 1e+17 or _missing_\n\n",
    "tanh": "**tanh(** _x_ **)** Description: the hyperbolic tangent of _x_ , **tanh(** _x_ **)** = {exp( _x_ ) - exp(- _x_ )}/{exp( _x_ ) + exp(- _x_ )} Domain: -8e+307 to 8e+307 Range: -1 to 1 or _missing_\n\n",
    "tC": "**tC(** _l_ **)** Description: convenience function to make typing dates and times in expressions easier Same as **tc()** , except returns leap second- adjusted values; for example, typing **tc(29nov2007 9:15)** is equivalent to typing **1511946900000** , whereas **tC(29nov2007** **9:15)** is **1511946923000**. Domain _l_ : datetime literal strings 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to >253,717,919,999,999)\n\n**tc(** _l_ **)** Description: convenience function to make typing dates and times in expressions easier For example, typing **tc(2jan1960 13:42)** is equivalent to typing **135720000** ; the date but not the time may be omitted, and then 01jan1960 is assumed; the seconds portion of the time may be omitted and is assumed to be 0.000; **tc(11:02)** is equivalent to typing **39720000**. Domain _l_ : datetime literal strings 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 Range: datetimes 01jan0100 00:00:00.000 to 31dec9999 23:59:59.999 (integers -58,695,840,000,000 to 253,717,919,999,999)\n\n",
    "td": "**td(** _l_ **)** Description: convenience function to make typing dates in expressions easier\n\nFor example, typing **td(2jan1960)** is equivalent to typing **1**. Domain _l_ : date literal strings 01jan0100 to 31dec9999 Range: **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549)\n\n",
    "tden": "**tden(** _df_ **,** _t_ **)** Description: the probability density function of Student's t distribution Domain _df_ : 1e-323 to 8e+307 (may be nonintegral) Domain _t_ : -8e+307 to 8e+307 Range: 0 to 0.39894 ...\n\n",
    "th": "**th(** _l_ **)** Description: convenience function to make typing half-yearly dates in expressions easier\n\nFor example, typing **th(1960h2)** is equivalent to typing **1**. Domain _l_ : half-year literal strings 0100h1 to 9999h2 Range: **%th** dates 0100h1 to 9999h2 (integers -3,720 to 16,079)\n\n",
    "tin": "**tin(** _d1_ **,** _d2_ **)** Description: _true_ if _d1_ _<_ _t_ _<_ _d2_ , where _t_ is the time variable previously **tsset**\n\nYou must have previously [**tsset**](https://www.stata.com/help.cgi?tsset) the data to use **tin()**. When you **tsset** the data, you specify a time variable _t_ , and the format on _t_ states how it is recorded. You type _d1_ and _d2_ according to that format.\n\nIf _t_ has a **%tc** format, you could type **tin(5jan1992** **11:15, 14apr2002 12:25)**.\n\nIf _t_ has a **%td** format, you could type **tin(5jan1992,** **14apr2002)**.\n\nIf _t_ has a **%tw** format, you could type **tin(1985w1,** **2002w15)**.\n\nIf _t_ has a **%tm** format, you could type **tin(1985m1,** **2002m4)**.\n\nIf _t_ has a **%tq** format, you could type **tin(1985q1,** **2002q2)**.\n\nIf _t_ has a **%th** format, you could type **tin(1985h1,** **2002h1)**.\n\nIf _t_ has a **%ty** format, you could type **tin(1985, 2002)**.\n\nOtherwise, _t_ is just a set of integers, and you could type **tin(12, 38)**.\n\nThe details of the **%t** format do not matter. If your _t_ is formatted **%tdnn/dd/yy** so that 5jan1992 displays as 1/5/92, you would still type the date in day-month-year order: **tin(5jan1992, 14apr2002)**. Domain _d1_ : date or time literals or strings recorded in units of _t_ previously **tsset** or blank to indicate no minimum date Domain _d2_ : date or time literals or strings recorded in units of _t_ previously **tsset** or blank to indicate no maximum date Range: 0 and 1, 1 means _true_\n\n",
    "tm": "**tm(** _l_ **)** Description: convenience function to make typing monthly dates in expressions easier For example, typing **tm(1960m2)** is equivalent to typing **1**. Domain _l_ : month literal strings 0100m1 to 9999m12 Range: **%tm** dates 0100m1 to 9999m12 (integers -22,320 to 96,479)\n\n",
    "tobytes": "**tobytes(** _s_ [ **,** _n_ ] **)** Description: escaped decimal or hex digit strings of up to 200 bytes of _s_ The escaped decimal digit string is in the form of **\\dDDD**. The escaped hex digit string is in the form of **\\xhh**. If _n_ is not specified or is 0, the decimal form is produced. Otherwise, the hex form is produced.\n\n**tobytes(\"abc\")** = **\"\\d097\\d098\\d099\"** **tobytes(\"abc\", 1)** = **\"\\x61\\x62\\x63\"** **tobytes(\"caf\u00c3\u00a9\")** = **\"\\d099\\d097\\d102\\d195\\d169\"** Domain _s_ : Unicode strings Domain _n_ : integers Range: strings\n\n",
    "tq": "**tq(** _l_ **)** Description: convenience function to make typing quarterly dates in expressions easier For example, typing **tq(1960q2)** is equivalent to typing **1**. Domain _l_ : quarter literal strings 0100q1 to 9999q4 Range: **%tq** dates 0100q1 to 9999q4 (integers -7,440 to 32,159)\n\n",
    "trace": "**trace(** _M_ **)** Description: the trace of matrix _M_ Domain: _n_ x _n_ (square) matrices Range: scalars -8e+307 to 8e+307\n\n",
    "trigamma": "**trigamma(** _x_ **)** Description: the second derivative of **lngamma(** _x_ **)**\n\nThe **trigamma()** function is the derivative of **digamma(** _x_ **)**. Domain: -1e+15 to 8e+307 Range: 0 to 8e+307 or _missing_\n\n",
    "ttail": "**ttail(** _df_ **,** _t_ **)** Description: the reverse cumulative (upper tail or survivor) Student's t distribution; the probability T  > _t_ Domain _df_ : 2e-10 to 2e+17 (may be nonintegral) Domain _t_ : -8e+307 to 8e+307 Range: 0 to 1\n\n",
    "tukeyprob": "**tukeyprob(** _k_ **,** _df_ **,** _x_ **)** Description: the cumulative Tukey's Studentized range distribution with _k_ ranges and _df_ degrees of freedom; **0** if _x_ < 0 If _df_ is a missing value, then the normal distribution is used instead of Student's t.\n\n**tukeyprob()** is computed using an algorithm described in [Miller (1981)](https://www.stata.com/help.cgi?density_functions#M1981). Domain _k_ : 2 to 1e+6 Domain _df_ : 2 to 1e+6 Domain _x_ : -8e+307 to 8e+307 Range: 0 to 1\n\n**_Reference_**\n\nMiller, R. G. 1981. _Simultaneous Statistical Inference_. 2nd ed. New York: Springer.\n\n",
    "tw": "**tw(** _l_ **)** Description: convenience function to make typing weekly dates in expressions easier For example, typing **tw(1960w2)** is equivalent to typing **1**. Domain _l_ : week literal strings 0100w1 to 9999w52 Range: **%tw** dates 0100w1 to 9999w52 (integers -96,720 to 418,079)\n\n",
    "twithin": "**twithin(** _d1_ **,** _d2_ **)** Description: _true_ if _d1_ < _t_ < _d2_ , where _t_ is the time variable previously **tsset**\n\nSee the [**tin()**](https://www.stata.com/help.cgi?tin\\(\\)) function; **twithin()** is similar, except the range is exclusive. Domain _d1_ : date or time literals or strings recorded in units of _t_ previously **tsset** or blank to indicate no minimum date Domain _d2_ : date or time literals or strings recorded in units of _t_ previously **tsset** or blank to indicate no maximum date Range: 0 and 1, 1 means _true_\n\n",
    "uchar": "**uchar(** _n_ **)** Description: the Unicode character corresponding to Unicode code point _n_ or an empty string if _n_ is beyond the Unicode code- point range\n\nNote that **uchar()** takes the decimal value of the Unicode code point. **ustrunescape()** takes an escaped hex digit string of the Unicode code point. For example, both **uchar(8364)** and **ustrunescape(\"\\u20ac\")** produce the Euro sign. Domain _n_ : integers _>_ 0 Range: Unicode characters\n\n",
    "udstrlen": "**udstrlen(** _s_ **)** Description: the number of display columns needed to display the Unicode string _s_ in the Stata Results window A Unicode character in the CJK (Chinese, Japanese, and Korean) encoding usually requires two display columns; a Latin character usually requires one column. Any invalid UTF-8 sequence requires one column.\n\n**udstrlen(\"\u4e2d\u503c\")** = **4** **ustrlen(\"\u4e2d\u503c\")** = **2** **strlen(\"\u4e2d\u503c\")** = **6** Domain _s_ : Unicode strings Range: integers _>_ 0\n\n",
    "udsubstr": "**udsubstr(** _s_ **,** _n1_ **,** _n2_ **)** Description: the Unicode substring of _s_ , starting at character _n1_ , for _n2_ display columns\n\nIf _n2_ = **.** ( _missing_ ), the remaining portion of the Unicode string is returned. If _n2_ display columns from _n1_ is in the middle of a Unicode character, the substring stops at the previous Unicode character.\n\n**udsubstr(\"m\u00e9diane\",2,3)** = **\"\u00e9di\"** **udsubstr(\"\u4e2d\u503c\",1,1)** = **\"\"** **udsubstr(\"\u4e2d\u503c\",1,2)** = **\"\u4e2d\"** Domain _s_ : Unicode strings Domain _n1_ : integers _>_ 1 Domain _n2_ : integers _>_ 1 Range: Unicode strings\n\n**_Remarks_**\n\nUse function [**usubstr()**](https://www.stata.com/help.cgi?usubstr\\(\\)) to extract a substring based on Unicode characters. Use function [**substr()**](https://www.stata.com/help.cgi?substr\\(\\)) to extract a substring based on bytes.\n\n",
    "uisdigit": "**uisdigit(** _s_ **)** Description: **1** if the first Unicode character in _s_ is a Unicode decimal digit; otherwise, **0**\n\nA Unicode decimal digit is a Unicode character with the character property **Nd** according to the Unicode standard. The function returns **-1** if the string starts with an invalid UTF-8 sequence. Domain _s_ : Unicode strings Range: integers\n\n",
    "uisletter": "**uisletter(** _s_ **)** Description: **1** if the first Unicode character in _s_ is a Unicode letter; otherwise, **0**\n\nA Unicode letter is a Unicode character with the character property **L** according to the Unicode standard. The function returns **-1** if the string starts with an invalid UTF-8 sequence. Domain _s_ : Unicode strings Range: integers\n\n",
    "ustrcompare": "**ustrcompare(** _s1_ **,** _s2_ [ **,** _loc_ ] **)** Description: compares two Unicode strings\n\nThe function returns **-1** , **1** , or **0** if _s1_ is less than, greater than, or equal to _s2_. The function may return a negative number other than -1 if an error happens. The comparison is locale dependent. For example, z  < \u00f6 in Swedish but \u00f6 < z in German. If _loc_ is not specified, the default locale is used. The comparison is diacritic and case sensitive. If you need different behavior, for example, case-insensitive comparison, you should use the extended comparison function **ustrcompareex()**. Unicode string comparison compares Unicode strings in a language-sensitive manner. On the other hand, the [**sort**](https://www.stata.com/help.cgi?sort) command compares strings in code-point (binary) order. For example, uppercase \"Z\" (code-point value 90) comes before lowercase \"a\" (code-point value 97) in code-point order but comes after \"a\" in any English dictionary.\n\n**ustrcompare(\"z\", \"\u00f6\", \"sv\")** = **-1** **ustrcompare(\"z\", \"\u00f6\", \"de\")** = **1** Domain _s1_ : Unicode strings Domain _s2_ : Unicode strings Domain _loc_ : Unicode strings Range: integers\n\n",
    "ustrsortkey": "**ustrsortkey(** _s_ [ **,** _loc_ ] **)** Description: generates a null- terminated byte array that can be used by the [**sort**](https://www.stata.com/help.cgi?sort) command to produce the same order as **ustrcompare()**\n\nThe function may return an empty array if an error occurs. The result is locale dependent. If _loc_ is not specified, the default locale is used. The result is also diacritic and case sensitive. If you need different behavior, for example, case-insensitive results, you should use the extended function **ustrsortkeyex()**. See **[U] 12.4.2.5 Sorting strings** **containing Unicode characters** for details and examples. Domain _s_ : Unicode strings Domain _loc_ : Unicode strings Range: null-terminated byte array\n\n",
    "ustrcompareex": "**ustrcompareex(** _s1_ **,** _s2_ **,** _loc_ **,** _st_ **,** _case_ **,** _cslv_ **,** _norm_ **,** _num_ **,** _alt_ **,** _fr_ **)** Description: compares two Unicode strings\n\nThe function returns **-1** , **1** , or **0** if _s1_ is less than, greater than, or equal to _s2_. The function may return a negative number other than **-1** if an error occurs. The comparison is locale dependent. For example, z < \u00f6 in Swedish but \u00f6 < z in German. If _loc_ is not specified, the default locale is used.\n\n_st_ controls the strength of the comparison. Possible values are **1** (primary), **2** (secondary), **3** (tertiary), **4** (quaternary), or **5** (identical). **-1** means to use the default value for the locale. Any other numbers are treated as tertiary. The primary difference represents base letter differences; for example, letter \"a\" and letter \"b\" have primary differences. The secondary difference represents diacritical differences on the same base letter; for example, letters \"a\" and \"\u00e4\" have secondary differences. The tertiary difference represents case differences of the same base letter; for example, letters \"a\" and \"A\" have tertiary differences. Quaternary strength is useful to distinguish between Katakana and Hiragana for the JIS 4061 collation standard. Identical strength is essentially the code-point order of the string, hence, is rarely useful.\n\n**ustrcompareex(\"caf\u00e9\",\"cafe\",\"fr\", 1, -1, -1, -1, -1, -1,** **-1)** = **0** **ustrcompareex(\"caf\u00e9\",\"cafe\",\"fr\", 2, -1, -1, -1, -1, -1,** **-1)** = **1** **ustrcompareex(\"Caf\u00e9\",\"caf\u00e9\",\"fr\", 3, -1, -1, -1, -1, -1,** **-1)** = **1**\n\n_case_ controls the uppercase and lowercase letter order. Possible values are **0** (use order specified in tertiary strength), **1** (uppercase first), or **2** (lowercase first). **-1** means to use the default value for the locale. Any other values are treated as **0**.\n\n**ustrcompareex(\"Caf\u00e9\",\"caf\u00e9\",\"fr\", -1, 1, -1, -1, -1, -1,** **-1)** = **-1** **ustrcompareex(\"Caf\u00e9\",\"caf\u00e9\",\"fr\", -1, 2, -1, -1, -1, -1,** **-1)** = **1**\n\n_cslv_ controls whether an extra case level between the secondary level and the tertiary level is generated. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. Any other values are treated as **0**. Combining this setting to be \"on\" and the strength setting to be primary can achieve the effect of ignoring the diacritical differences but preserving the case differences. If the setting is \"on\", the result is also affected by the _case_ setting.\n\n**ustrcompareex(\"caf\u00e9\",\"Cafe\",\"fr\", 1, -1, 1, -1, -1, -1,** **-1)** = **-1** **ustrcompareex(\"caf\u00e9\",\"Cafe\",\"fr\", 1, 1, 1, -1, -1, -1,** **-1)** = **1**\n\n_norm_ controls whether the normalization check and normalizations are performed. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. Any other values are treated as **0**. Most languages do not require normalization for comparison. Normalization is needed in languages that use multiple combining characters such as Arabic, ancient Greek, or Hebrew.\n\n_num_ controls how contiguous digit substrings are sorted. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. Any other values are treated as **0**. If the setting is \"on\", substrings consisting of digits are sorted based on the numeric value. For example, \"100\" is after value \"20\" instead of before it. Note that the digit substring is limited to 254 digits, and plus/minus signs, decimals, or exponents are not supported.\n\n**ustrcompareex(\"100\", \"20\",\"en\", -1, -1, -1, -1, 0, -1,** **-1)** = **-1** **ustrcompareex(\"100\", \"20\",\"en\", -1, -1, -1, -1, 1, -1,** **-1)** = **1**\n\n_alt_ controls how spaces and punctuation characters are handled. Possible values are **0** (use primary strength) or **1** (alternative handling). Any other values are treated as **0**. If the setting is **1** (alternative handling), \"onsite\", \"on-site\", and \"on site\" are considered equals.\n\n**ustrcompareex(\"onsite\", \"on-site\",\"en\", -1, -1, -1, -1,** **-1, 1, -1)** = **0** **ustrcompareex(\"onsite\", \"on site\",\"en\", -1, -1, -1, -1,** **-1, 1, -1)** = **0** **ustrcompareex(\"onsite\", \"on-site\",\"en\", -1, -1, -1, -1,** **-1, 0, -1)** = **1**\n\n_fr_ controls the direction of the secondary strength. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. All other values are treated as \"off\". If the setting is \"on\", the diacritical letters are sorted backward. Note that the setting is \"on\" by default only for Canadian French (locale **fr_CA** ).\n\n**ustrcompareex(\"cot\u00e9\",** **\"c\u00f4te\",\"fr_CA\",-1,-1,-1,-1,-1,-1,0)** = **-1** **ustrcompareex(\"cot\u00e9\",** **\"c\u00f4te\",\"fr_CA\",-1,-1,-1,-1,-1,-1,1)** = **1** **ustrcompareex(\"cot\u00e9\",** **\"c\u00f4te\",\"fr_CA\",-1,-1,-1,-1,-1,-1,-1)** = **1** **ustrcompareex(\"cot\u00e9\", \"c\u00f4te\",\"fr\",-1,-1,-1,-1,-1,-1,-1)** = **1** Domain _s1_ : Unicode strings Domain _s2_ : Unicode strings Domain _loc_ : Unicode strings Domain _st_ : integers Domain _case_ : integers Domain _cslv_ : integers Domain _norm_ : integers Domain _num_ : integers Domain _alt_ : integers Domain _fr_ : integers Range: integers\n\n",
    "ustrsortkeyex": "**ustrsortkeyex(** _s_ **,** _loc_ **,** _st_ **,** _case_ **,** _cslv_ **,** _norm_ **,** _num_ **,** _alt_ **,** _fr_ **)** Description: generates a null- terminated byte array that can be used by the [**sort**](https://www.stata.com/help.cgi?sort) command to produce the same order as **ustrcompare()** The function may return an empty array if an error occurs. The result is locale dependent. If _loc_ is not specified, the default locale is used. See **[U] 12.4.2.5** **Sorting strings containing Unicode characters** for details and examples.\n\n_st_ controls the strength of the comparison. Possible values are **1** (primary), **2** (secondary), **3** (tertiary), **4** (quaternary), or **5** (identical). **-1** means to use the default value for the locale. Any other numbers are treated as tertiary. The primary difference represents base letter differences; for example, letter \"a\" and letter \"b\" have primary differences. The secondary difference represents diacritical differences on the same base letter; for example, letters \"a\" and \"\u00e4\" have secondary differences. The tertiary difference represents case differences of the same base letters; for example, letters \"a\" and \"A\" have tertiary differences. Quaternary strength is useful to distinguish between Katakana and Hiragana for the JIS 4061 collation standard. Identical strength is essentially the code-point order of the string and, hence, is rarely useful.\n\n_case_ controls the uppercase and lowercase letter order. Possible values are **0** (use order specified in tertiary strength), **1** (uppercase first), or **2** (lowercase first). **-1** means to use the default value for the locale. Any other values are treated as **0**.\n\n_cslv_ controls if an extra case level between the secondary level and the tertiary level is generated. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. Any other values are treated as **0**. Combining this setting to be \"on\" and the strength setting to be primary can achieve the effect of ignoring the diacritical differences but preserving the case differences. If the setting is \"on\", the result is also affected by the _case_ setting.\n\n_norm_ controls whether the normalization check and normalizations are performed. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. Any other values are treated as **0**. Most languages do not require normalization for comparison. Normalization is needed in languages that use multiple combining characters such as Arabic, ancient Greek, or Hebrew.\n\n_num_ controls how contiguous digit substrings are sorted. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. Any other values are treated as **0**. If the setting is \"on\", substrings consisting of digits are sorted based on the numeric value. For example, \"100\" is after \"20\" instead of before it. Note that the digit substring is limited to 254 digits, and plus/minus signs, decimals, or exponents are not supported.\n\n_alt_ controls how spaces and punctuation characters are handled. Possible values are **0** (use primary strength) or **1** (alternative handling). Any other values are treated as **0**. If the setting is **1** (alternative handling), \"onsite\", \"on-site\", and \"on site\" are considered equals.\n\n_fr_ controls the direction of the secondary strength. Possible values are **0** (off) or **1** (on). **-1** means to use the default value for the locale. All other values are treated as \"off\". If the setting is \"on\", the diacritical letters are sorted backward. Note that the setting is \"on\" by default only for Canadian French (locale **fr_CA** ). Domain _s_ : Unicode strings Domain _loc_ : Unicode strings Domain _st_ : integers Domain _case_ : integers Domain _cslv_ : integers Domain _norm_ : integers Domain _num_ : integers Domain _alt_ : integers Domain _fr_ : integers Range: null-terminated byte array\n\n",
    "ustrfix": "**ustrfix(** _s_ [ **,** _rep_ ] **)** Description: replaces each invalid UTF-8 sequence with a Unicode character In the one-argument case, the Unicode replacement character **\\ufffd** is used. In the two-argument case, the first Unicode character of _rep_ is used. If _rep_ starts with an invalid UTF-8 sequence, then Unicode replacement character **\\ufffd** is used. Note that an invalid UTF-8 sequence can contain one byte or multiple bytes.\n\n**ustrfix(char(200))** = **ustrunescape(\"\\ufffd\")** **ustrfix(\"ab\"+char(200)+\"cd\u00e9\", \"\")** = **\"abcd\u00e9\"** **ustrfix(\"ab\"+char(229)+char(174)+\"cd\u00e9\", \"\u00e9\")** = **\"ab\u00e9cd\u00e9\"** Domain _s_ : Unicode strings Domain _rep_ : Unicode character Range: Unicode strings\n\n",
    "ustrto": "**ustrto(** _s_ **,** _enc_ **,** _mode_ **)** Description: converts the Unicode string _s_ in UTF-8 encoding to a string in encoding _enc_ See [**[D] unicode encoding**](https://www.stata.com/help.cgi?unicode_encoding) for details on available encodings. Any invalid sequence in _s_ is replaced with a Unicode replacement character **\\ufffd**. _mode_ controls how unsupported Unicode characters in the encoding _enc_ are handled. The possible values are **1** , which substitutes any unsupported characters with the _enc_ 's substitution strings (the substitution character for both **ascii** and **latin1** is **char(26)** ); **2** , which skips any unsupported characters; **3** , which stops at the first unsupported character and returns an empty string; or **4** , which replaces any unsupported character with an escaped hex digit sequence **\\uhhhh** or **\\Uhhhhhhhh**. The hex digit sequence contains either 4 or 8 hex digits, depending if the Unicode character's code- point value is less than or greater than **\\uffff**. Any other values are treated as **1**.\n\n**ustrto(\"caf\u00e9\", \"ascii\", 1)** = **\"caf\"+char(26)** **ustrto(\"caf\u00e9\", \"ascii\", 2)** = **\"caf\"** **ustrto(\"caf\u00e9\", \"ascii\", 3)** = **\"\"** **ustrto(\"caf\u00e9\", \"ascii\", 4)** = **\"caf\\u00E9\"** **ustrto()** can be used to removed diacritical marks from base letters. First, normalize the Unicode string to **NFD** form using **ustrnormalize()** , and then call **ustrto()** with value **2** to skip all non-ASCII characters.\n\nAlso see [**ustrfrom()**](https://www.stata.com/help.cgi?ustrfrom\\(\\)).\n\n**ustrto(ustrnormalize(\"caf\u00e9\", \"nfd\"), \"ascii\", 2)** = **\"cafe\"** Domain _s_ : Unicode strings Domain _enc_ : Unicode strings Domain _mode_ : integers Range: strings in encoding _enc_\n\n",
    "ustrfrom": "**ustrfrom(** _s_ **,** _enc_ **,** _mode_ **)** Description: converts the string _s_ in encoding _enc_ to a UTF-8 encoded Unicode string _mode_ controls how invalid byte sequences in _s_ are handled. The possible values are **1** , which substitutes an invalid byte sequence with a Unicode replacement character **\\ufffd** ; **2** , which skips any invalid byte sequences; **3** , which stops at the first invalid byte sequence and returns an empty string; or **4** , which replaces any byte in an invalid sequence with an escaped hex digit sequence **%Xhh**. Any other values are treated as **1**. A good use of value **4** is to check what invalid bytes a Unicode string _ust_ contains by examining the result of **ustrfrom(ust, \"utf-8\", 4)**.\n\nAlso see [**ustrto()**](https://www.stata.com/help.cgi?ustrto\\(\\)).\n\n**ustrfrom(\"caf\"+char(233), \"latin1\", 1)** = **\"caf\u00e9\"** **ustrfrom(\"caf\"+char(233), \"utf-8\", 1)** = **\"caf\"+ustrunescape(\"\\ufffd\")** **ustrfrom(\"caf\"+char(233), \"utf-8\", 2)** = **\"caf\"** **ustrfrom(\"caf\"+char(233), \"utf-8\", 3)** = **\"\"** **ustrfrom(\"caf\"+char(233), \"utf-8\", 4)** = **\"caf%XE9\"** Domain _s_ : strings in encoding _enc_ Domain _enc_ : Unicode strings Domain _mode_ : integers Range: Unicode strings\n\n",
    "ustrlen": "**ustrlen(** _s_ **)** Description: the number of characters in the Unicode string _s_\n\nAn invalid UTF-8 sequence is counted as one Unicode character. An invalid UTF-8 sequence may contain one byte or multiple bytes. Note that any Unicode character beyond the plain ASCII range (code point greater than 127) takes more than 1 byte in the UTF-8 encoding; for example, **\u00e9** takes 2 bytes.\n\n**ustrlen(\"m\u00e9diane\")** = **7** **strlen(\"m\u00e9diane\")** = **8** Domain _s_ : Unicode strings Range: integers _>_ 0\n\n",
    "ustrinvalidcnt": "**ustrinvalidcnt(** _s_ **)** Description: the number of invalid UTF-8 sequences in _s_\n\nAn invalid UTF-8 sequence may contain one byte or multiple bytes.\n\n**ustrinvalidcnt(\"m\u00e9diane\")** = **0** **ustrinvalidcnt(\"m\u00e9diane\"+char(229))** = **1** **ustrinvalidcnt(\"m\u00e9diane\"+char(229)+char(174))** = **1** **ustrinvalidcnt(\"m\u00e9diane\"+char(174)+char(158))** = **2** Domain _s_ : Unicode strings Range: integers\n\n",
    "usubstr": "**usubstr(** _s_ **,** _n1_ **,** _n2_ **)** Description: the Unicode substring of _s_ , starting at _n1_ , for a length of _n2_ If _n1_ < 0, _n1_ is interpreted as the distance from the last character of the _s_ ; if _n2_ = **.** ( _missing_ ), the remaining portion of the Unicode string is returned. **usubstr(\"m\u00e9diane\",2,3)** = **\"\u00e9di\"** **usubstr(\"m\u00e9diane\",-3,2)** = **\"an\"** **usubstr(\"m\u00e9diane\",2,.)** = **\"\u00e9diane\"** Domain _s_ : Unicode strings Domain _n1_ : integers _>_ 1 and _<_ -1 Domain _n2_ : integers _>_ 1 Range: Unicode strings\n\n",
    "ustrleft": "**ustrleft(** _s_ **,** _n_ **)** Description: the first _n_ Unicode characters of the Unicode string _s_ An invalid UTF-8 sequence is replaced with a Unicode replacement character **\\ufffd**.\n\n**ustrleft(\"\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435\",3)** = **\"\u042d\u043a\u0441\"** **ustrleft(\"\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435\",5)** = **\"\u042d\u043a\u0441\u043f\u0435\"** Domain _s_ : Unicode strings Domain _n_ : integers Range: Unicode strings\n\n",
    "ustrright": "**ustrright(** _s_ **,** _n_ **)** Description: the last _n_ Unicode characters of the Unicode string _s_\n\nAn invalid UTF-8 sequence is replaced with a Unicode replacement character **\\ufffd**.\n\n**ustrright(\"\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435\",3)** = **\"\u043d\u044b\u0435\"** **ustrright(\"\u042d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u044b\u0435\",5)** = **\"\u043b\u044c\u043d\u044b\u0435\"** Domain _s_ : Unicode strings Domain _n_ : integers Range: Unicode strings\n\n**_Remarks_**\n\nUse function [**udsubstr()**](https://www.stata.com/help.cgi?udsubstr\\(\\)) to extract a substring based on display columns. Use function [**substr()**](https://www.stata.com/help.cgi?substr\\(\\)) to extract a substring based on bytes.\n\n",
    "ustrupper": "**ustrupper(** _s_ [ **,** _loc_ ] **)** Description: uppercase all characters in string _s_ under the given locale _loc_\n\nIf _loc_ is not specified, the default locale is used. The same _s_ but a different _loc_ may produce different results; for example, the uppercase letter of \"i\" is \"I\" in English, but \"I\" with a dot in Turkish. The result can be longer or shorter than the input string in bytes; for example, the uppercase form of the German letter \u00df (code point **\\u00df** ) is two capital letters \"SS\".\n\n**ustrupper(\"m\u00e9diane\",\"fr\")** = **\"M\u00c9DIANE\"** **ustrupper(\"Ru\u00dfland\", \"de\")** = **\"RUSSLAND\"** **ustrupper(\"istanbul\", \"tr\")** = **\"\u0130STANBUL\"** Domain _s_ : Unicode strings Domain _loc_ : locale name Range: Unicode strings\n\n",
    "ustrlower": "**ustrlower(** _s_ [ **,** _loc_ ] **)** Description: lowercase all characters of Unicode string _s_ under the given locale _loc_ If _loc_ is not specified, the default locale is used. The same _s_ but different _loc_ may produce different results; for example, the lowercase letter of \"I\" is \"i\" in English but a dotless \"i\" in Turkish. The same Unicode character can be mapped to different Unicode characters based on its surrounding characters; for example, Greek capital letter sigma \u03a3 has two lowercases: \u03c2, if it is the final character of a word, or \u03c3. The result can be longer or shorter than the input Unicode string in bytes.\n\n**ustrlower(\"M\u00c9DIANE\",\"fr\")** = **\"m\u00e9diane\"** **ustrlower(\"ISTANBUL\",\"tr\")** = **\"\u0131stanbul\"** **ustrlower(\"\u1f48\u0394\u03a5\u03a3\u03a3\u0395\u038e\u03a3\")** = **\"\u1f40\u03b4\u03c5\u03c3\u03c3\u03b5\u03cd\u03c2\"** Domain _s_ : Unicode strings Domain _loc_ : locale name Range: Unicode strings\n\n",
    "ustrtitle": "**ustrtitle(** _s_ [ **,** _loc_ ] **)** Description: a string with the first characters of Unicode words titlecased and other characters lowercased\n\nIf _loc_ is not specified, the default locale is used. Note that a Unicode word is different from a Stata word produced by function [**word()**](https://www.stata.com/help.cgi?word\\(\\)). The Stata word is a space-separated token. A Unicode word is a language unit based on either a set of word-boundary rules or dictionaries for some languages (Chinese, Japanese, and Thai). The titlecase is also locale dependent and context sensitive; for example, lowercase \"ij\" is considered a digraph in Dutch. Its titlecase is \"IJ\".\n\n**ustrtitle(\"vous \u00eates\", \"fr\")** = **\"Vous \u00cates\"** **ustrtitle(\"mR. joHn a. sMitH\")** = **\"Mr. John A. Smith\"** **ustrtitle(\"ijmuiden\", \"en\")** = **\"Ijmuiden\"** **ustrtitle(\"ijmuiden\", \"nl\")** = **\"IJmuiden\"** Domain _s_ : Unicode strings Domain _loc_ : Unicode strings Range: Unicode strings\n\n**_Remarks_**\n\nUse functions [**strupper()**](https://www.stata.com/help.cgi?strupper\\(\\)) and [**strlower()**](https://www.stata.com/help.cgi?strlower\\(\\)) to convert only ASCII letters to uppercase and lowercase.\n\n",
    "ustrtrim": "**ustrtrim(** _s_ **)** Description: removes leading and trailing Unicode whitespace characters and blanks from the Unicode string _s_\n\nNote that, in addition to **char(32)** , ASCII characters **char(9)** , **char(10)** , **char(11)** , **char(12)** , and **char(13)** are considered whitespace characters in the Unicode standard.\n\n**ustrtrim(\" this \")** = **\"this\"** **ustrtrim(char(11)+\" this \")+char(13)** = **\"this\"** **ustrtrim(\" this \"+ustrunescape(\"\\u2000\"))** = **\"this\"** Domain _s_ : Unicode strings Range: Unicode strings\n\n",
    "ustrltrim": "**ustrltrim(** _s_ **)** Description: removes the leading Unicode whitespace characters and blanks from the Unicode string _s_ Note that, in addition to **char(32)** , ASCII characters **char(9)** , **char(10)** , **char(11)** , **char(12)** , and **char(13)** are whitespace characters in Unicode standard.\n\n**ustrltrim(\" this\")** = **\"this\"** **ustrltrim(char(9)+\"this\")** = **\"this\"** **ustrltrim(ustrunescape(\"\\u1680\")+\" this\")** = **\"this\"** Domain _s_ : Unicode strings Range: Unicode strings\n\n",
    "ustrrtrim": "**ustrrtrim(** _s_ **)** Description: remove trailing Unicode whitespace characters and blanks from the Unicode string _s_ Note that, in addition to **char(32)** , ASCII characters **char(9)** , **char(10)** , **char(11)** , **char(12)** , and **char(13)** are considered whitespace characters in the Unicode standard.\n\n**ustrrtrim(\"this \")** = **\"this\"** **ustrltrim(\"this\"+char(10))** = **\"this\"** **ustrrtrim(\"this \"+ustrunescape(\"\\u2000\"))** = **\"this\"** Domain _s_ : Unicode strings Range: Unicode strings\n\n**_Remarks_**\n\nUse functions [**strtrim()**](https://www.stata.com/help.cgi?strtrim\\(\\)), [**stritrim()**](https://www.stata.com/help.cgi?stritrim\\(\\)), [**strltrim()**](https://www.stata.com/help.cgi?strltrim\\(\\)), and [**strrtrim()**](https://www.stata.com/help.cgi?strrtrim\\(\\)) to trim only the ASCII space character **char(32)**.\n\n",
    "ustrnormalize": "**ustrnormalize(** _s_ **,** _norm_ **)** Description: normalizes Unicode string _s_ to one of the five normalization forms specified by _norm_\n\nThe normalization forms are **nfc** , **nfd** , **nfkc** , **nfkd** , or **nfkcc**. The function returns an empty string for any other value of _norm_. Unicode normalization removes the Unicode string differences caused by Unicode character equivalence. **nfc** specifies **Normalization Form C** , which normalizes decomposed Unicode code points to a composited form. **nfd** specifies **Normalization Form D** , which normalizes composited Unicode code points to a decomposed form. **nfc** and **nfd** produce canonical equivalent form. **nfkc** and **nfkd** are similar to **nfc** and **nfd** but produce compatibility equivalent forms. **nfkcc** specifies **nfkc** with casefolding. This normalization and casefolding implement the Unicode Character Database.\n\nIn the Unicode standard, both \"i\" ( **\\u0069** followed by a diaeresis **\\u0308** ) and the composite character **\\u00ef** represent \"i\" with 2 dots as in \"na\u00efve\". Hence, the code-point sequence **\\u0069\\u0308** and the code point **\\u00ef** are considered Unicode equivalent. According to the Unicode standard, they should be treated as the same single character in Unicode string operations, such as in display, comparison, and selection. However, Stata does not support multiple code-point characters; each code point is considered a separate Unicode character. Hence, **\\u0069\\u0308** is displayed as two characters in the Results window. **ustrnormalize()** can be used with **\"nfc\"** to normalize **\\u0069\\u0308** to the canonical equivalent composited code point **\\u00ef**.\n\n**ustrnormalize(ustrunescape(\"\\u0069\\u0308\"), \"nfc\")** = **\"\u00ef\"**\n\nThe decomposed form **nfd** can be used to removed diacritical marks from base letters. First, normalize the Unicode string to canonical decomposed form, and then call [**ustrto()**](https://www.stata.com/help.cgi?f_ustrto) with mode **skip** to skip all non-ASCII characters.\n\nAlso see [**ustrfrom()**](https://www.stata.com/help.cgi?f_ustrfrom).\n\n**ustrto(ustrnormalize(\"caf\u00e9\", \"nfd\"), \"ascii\", 2)** = **\"cafe\"** Domain _s_ : Unicode strings Domain _norm_ : Unicode strings Range: Unicode strings\n\n",
    "ustrpos": "**ustrpos(** _s1_ **,** _s2_ [ **,** _n_ ] **)** Description: the position in _s1_ at which _s2_ is first found; otherwise, **0** If _n_ is specified and is greater than 0, the search starts at the _n_ th Unicode character of _s1_. An invalid UTF-8 sequence in either _s1_ or _s2_ is replaced with a Unicode replacement character **\\ufffd** before the search is performed.\n\n**ustrpos(\"m\u00e9diane\", \"\u00e9di\")** = **2** **ustrpos(\"m\u00e9diane\", \"\u00e9di\", 3)** = **0** **ustrpos(\"m\u00e9diane\", \"\u00e9ci\")** = **0** Domain _s1_ : Unicode strings (to be searched) Domain _s2_ : Unicode strings (to search for) Domain _n_ : integers Range: integers\n\n",
    "ustrrpos": "**ustrrpos(** _s1_ **,** _s2_ [ **,** _n_ ] **)** Description: the position in _s1_ at which _s2_ is last found; otherwise, **0** If _n_ is specified and is greater than 0, only the part between the first Unicode character and the _n_ th Unicode character of _s1_ is searched. An invalid UTF-8 sequence in either _s1_ or _s2_ is replaced with a Unicode replacement character **\\ufffd** before the search is performed.\n\n**ustrrpos(\"enchant\u00e9\", \"n\")** = **6** **ustrrpos(\"enchant\u00e9\", \"n\", 5)** = **2** **ustrrpos(\"enchant\u00e9\", \"n\", 6)** = **6** **ustrrpos(\"enchant\u00e9\", \"ne\")** = **0** Domain _s1_ : Unicode strings (to be searched) Domain _s2_ : Unicode strings (to search for) Domain _n_ : integers Range: integers\n\n**_Remarks_**\n\nUse functions [**strpos()**](https://www.stata.com/help.cgi?strpos\\(\\)) and [**strrpos()**](https://www.stata.com/help.cgi?strrpos\\(\\)) to find the byte- based location of a substring in a string.\n\n",
    "ustrregexm": "**ustrregexm(** _s_ **,** _re_ [ **,** _noc_ ] **)** Description: performs a match of a regular expression and evaluates to **1** if regular expression _re_ is satisfied by the Unicode string _s_ ; otherwise, **0**\n\nIf _noc_ is specified and not 0, a case-insensitive match is performed. The function may return a negative integer if an error occurs.\n\n**ustrregexm(\"12345\", \"([0-9]){5}\")** = **1** **ustrregexm(\"de TR\u00c8S pr\u00e8s\", \"r\u00e8s\")** = **1** **ustrregexm(\"de TR\u00c8S pr\u00e8s\", \"R\u00e8s\")** = **0** **ustrregexm(\"de TR\u00c8S pr\u00e8s\", \"R\u00e8s\", 1)** = **1** Domain _s_ : Unicode strings Domain _re_ : Unicode regular expressions Domain _noc_ : integers Range: integers\n\n",
    "ustrregexrf": "**ustrregexrf(** _s1_ **,** _re_ **,** _s2_ [ **,** _noc_ ] **)** Description: replaces the first substring within the Unicode string _s1_ that matches _re_ with _s2_ and returns the resulting string If _noc_ is specified and not 0, a case-insensitive match is performed. The function may return an empty string if an error occurs.\n\n**ustrregexrf(\"tr\u00e8s pr\u00e8s\", \"r\u00e8s\", \"X\")** = **\"tX pr\u00e8s\"** **ustrregexrf(\"TR\u00c8S pr\u00e8s\", \"R\u00e8s\", \"X\")** = **\"TR\u00c8S pr\u00e8s\"** **ustrregexrf(\"TR\u00c8S pr\u00e8s\", \"R\u00e8s\", \"X\", 1)** = **\"TX pr\u00e8s\"** Domain _s1_ : Unicode strings Domain _re_ : Unicode regular expressions Domain _s2_ : Unicode strings Domain _noc_ : integers Range: Unicode strings\n\n",
    "ustrregexra": "**ustrregexra(** _s1_ **,** _re_ **,** _s2_ [ **,** _noc_ ] **)** Description: replaces all substrings within the Unicode string _s1_ that match _re_ with _s2_ and returns the resulting string If _noc_ is specified and not 0, a case- insensitive match is performed. The function may return an empty string if an error occurs.\n\n**ustrregexra(\"tr\u00e8s pr\u00e8s\", \"r\u00e8s\", \"X\")** = **\"tX pX\"** **ustrregexra(\"TR\u00c8S pr\u00e8s\", \"R\u00e8s\", \"X\")** = **\"TR\u00c8S pr\u00e8s\"** **ustrregexra(\"TR\u00c8S pr\u00e8s\", \"R\u00e8s\", \"X\", 1)** = **\"TX pX\"** Domain _s1_ : Unicode strings Domain _re_ : Unicode regular expressions Domain _s2_ : Unicode strings Domain _noc_ : integers Range: Unicode strings\n\n",
    "ustrregexs": "**ustrregexs(** _n_ **)** Description: subexpression _n_ from a previous **ustrregexm()** match Subexpression 0 is reserved for the entire string that satisfied the regular expression. The function may return an empty string if _n_ is larger than the maximum count of subexpressions from the previous match or if an error occurs. Domain _n_ : integers _>_ 0 Range: strings\n\n",
    "ustrreverse": "**ustrreverse(** _s_ **)** Description: reverses the Unicode string _s_\n\nThe function does not take Unicode character equivalence into consideration. Hence, a Unicode character in a decomposed form will not be reversed as one unit. An invalid UTF-8 sequence is replaced with a Unicode replacement character **\\ufffd**.\n\n**ustrreverse(\"m\u00e9diane\")** = **\"enaid\u00e9m\"** Domain _s_ : Unicode strings Range: reversed Unicode strings\n\n",
    "ustrunescape": "**ustrunescape(** _s_ **)** Description: the Unicode string corresponding to the escaped sequences of _s_ The following escape sequences are recognized: 4 hex digit form **\\uhhhh** ; 8 hex digit form **\\Uhhhhhhhh** ; 1-2 hex digit form **\\xhh** ; and 1-3 octal digit form **\\ooo** , where **h** is **[0-9A-Fa-f]** and **o** is **[0-7]**. The standard ANSI C escapes **\\a** , **\\b** , **\\t** , **\\n** , **\\v** , **\\f** , **\\r** , **\\e** , **\\\"** , **\\'** , **\\?** , **\\\\\\** are recognized as well. The function returns an empty string if an escape sequence is badly formed. Note that the 8 hex digit form **\\Uhhhhhhhh** begins with a capital letter \"U\".\n\nAlso see [**ustrtohex()**](https://www.stata.com/help.cgi?ustrtohex\\(\\)).\n\n**ustrunescape(\"\\u043d\\u0443\\u043b\\u044e\")** = **\"\u043d\u0443\u043b\u044e\"** Domain _s_ : strings of escaped hex values Range: Unicode strings\n\n",
    "ustrtohex": "**ustrtohex(** _s_ [ **,** _n_ ] **)** Description: escaped hex digit string of _s_ up to 200 Unicode characters The escaped hex digit string is in the form of **\\uhhhh** for code points less than **\\uffff** or **\\Uhhhhhhhh** for code points greater than **\\uffff**. The function starts at the _n_ th Unicode character of _s_ if _n_ is specified and larger than 0. Any invalid UTF-8 sequence is replaced with a Unicode replacement character **\\ufffd**. Note that the null terminator **char(0)** is a valid Unicode character. Function [**ustrunescape()**](https://www.stata.com/help.cgi?f_ustrunescape) can be applied on the result to get back the original Unicode string _s_ if _s_ does not contain any invalid UTF-8 sequences.\n\nAlso see [**ustrunescape()**](https://www.stata.com/help.cgi?ustrunescape\\(\\)).\n\n**ustrtohex(\"\u043d\u0443\u043b\u044e\")** = **\"\\u043d\\u0443\\u043b\\u044e\"** **ustrtohex(\"\u043d\u0443\u043b\u044e\", 2)** = **\"\\u0443\\u043b\\u044e\"** **ustrtohex(\"i\"+char(200)+char(0)+\"s\")** = **\"\\u0069\\ufffd\\u0000\\u0073\"** Domain _s_ : Unicode strings Domain _n_ : integers >= 1 Range: strings\n\n",
    "ustrtoname": "**ustrtoname(** _s_ [ **,** _p_ ] **)** Description: string _s_ translated into a Stata name\n\n**ustrtoname()** results in a name that is truncated to 32 characters. Each character in _s_ that is not allowed in a Stata name is converted to an underscore character, **_**. If the first character in _s_ is a numeric character and _p_ is not 0, then the result is prefixed with an underscore.\n\n**ustrtoname(\"name\",1)** = **\"name\"** **ustrtoname(\"the m\u00e9diane\")** = **\"the_m\u00e9diane\"** **ustrtoname(\"0m\u00e9diane\")** = **\"_0m\u00e9diane\"** **ustrtoname(\"0m\u00e9diane\", 1)** = **\"_0m\u00e9diane\"** **ustrtoname(\"0m\u00e9diane\", 0)** = **\"0m\u00e9diane\"** Domain _s_ : Unicode strings Domain _p_ : integers 0 or 1 Range: Unicode strings\n\n",
    "ustrword": "**ustrword(** _s_ **,** _n_ [ **,** _loc_ ] **)** Description: the _n_ th Unicode word in the Unicode string _s_ Positive _n_ counts Unicode words from the beginning of _s_ , and negative _n_ counts Unicode words from the end of _s_. For examples, _n_ equal to 1 returns the first word in _s_ , and _n_ equal to -1 returns the last word in _s_. If _loc_ is not specified, the default locale is used. A Unicode word is different from a Stata word produced by the [**word()**](https://www.stata.com/help.cgi?f_word) function. A Stata word is a space-separated token. A Unicode word is a language unit based on either a set of word-boundary rules or dictionaries for some languages (Chinese, Japanese, and Thai). The function returns _missing_ ( **\"\"** ) if _n_ is greater than _cnt_ or less than _-cnt_ , where _cnt_ is the number of words _s_ contains. _cnt_ can be obtained from **ustrwordcount()**. The function also returns _missing_ ( **\"\"** ) if an error occurs.\n\n**ustrword(\"Parlez-vous fran\u00e7ais\", 1, \"fr\")** = **\"Parlez\"** **ustrword(\"Parlez-vous fran\u00e7ais\", 2, \"fr\")** = **\"-\"** **ustrword(\"Parlez- vous fran\u00e7ais\",-1, \"fr\")** = **\"fran\u00e7ais\"** **ustrword(\"Parlez-vous fran\u00e7ais\",-2, \"fr\")** = **\"vous\"** Domain _s_ : Unicode strings Domain _loc_ : Unicode strings Domain _n_ : integers Range: Unicode strings\n\n",
    "ustrwordcount": "**ustrwordcount(** _s_ [ **,** _loc_ ] **)** Description: the number of nonempty Unicode words in the Unicode string _s_ An empty Unicode word is a Unicode word consisting of only Unicode whitespace characters. If _loc_ is not specified, the default locale is used. A Unicode word is different from a Stata word produced by the [**word()**](https://www.stata.com/help.cgi?f_word) function. A Stata word is a space-separated token. A Unicode word is a language unit based on either a set of word-boundary rules or dictionaries for some languages (Chinese, Japanese, and Thai). The function may return a negative number if an error occurs.\n\n**ustrwordcount(\"Parlez-vous fran\u00e7ais\", \"fr\")** = **4** Domain _s_ : Unicode strings Domain _loc_ : Unicode strings Range: integers\n\n",
    "usubinstr": "**usubinstr(** _s1_ **,** _s2_ **,** _s3_ **,** _n_ **)** Description: replaces the first _n_ occurrences of the Unicode string _s2_ with the Unicode string _s3_ in _s1_ If _n_ is _missing_ , all occurrences are replaced. An invalid UTF-8 sequence in _s1_ , _s2_ , or _s3_ is replaced with a Unicode replacement character **\\ufffd** before replacement is performed.\n\n**usubinstr(\"de tr\u00e8s pr\u00e8s\",\"\u00e8s\",\"es\",1)** = **\"de tres pr\u00e8s\"** **usubinstr(\"de tr\u00e8s pr\u00e8s\",\"\u00e8s\",\"X\",2)** = **\"de trX prX\"** Domain _s1_ : Unicode strings (to be substituted into) Domain _s2_ : Unicode strings (to be substituted from) Domain _s3_ : Unicode strings (to be substituted with) Domain _n_ : integers _>_ 0 or _missing_ Range: Unicode strings\n\n",
    "vec": "**vec(** _M_ **)** Description: a column vector formed by listing the elements of _M_ , starting with the first column and proceeding column by column Domain: matrices Range: column vectors ( _n_ x 1 matrices)\n\n",
    "vecdiag": "**vecdiag(** _M_ **)** Description: the row vector containing the diagonal of matrix _M_\n\n**vecdiag()** is the opposite of [**diag()**](https://www.stata.com/help.cgi?diag\\(\\)). The row name is set to **r1** ; the column names are obtained from the column names of _M_. Domain: _n_ x _n_ matrices Range: 1 x _n_ vectors\n\n",
    "week": "**week(** _e_d_ **)** Description: the numeric week of the year corresponding to date _e_d_ , the **%td** encoded date (days since 01jan1960)\n\nNote: The first week of a year is the first 7-day period of the year. Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 1 to 52 or _missing_\n\n",
    "weekly": "**weekly(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_w_ weekly date (weeks since 1960w1) corresponding to _s1_ based on _s2_ and _Y_ ; _Y_ specifies _topyear_ ; see [**date()**](https://www.stata.com/help.cgi?date\\(\\)) Domain _s1_ : strings Domain _s2_ : strings **\"WY\"** and **\"YW\"** ; **Y** may be prefixed with _##_ Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: **%tw** dates 0100w1 to 9999w52 (integers -96,720 to 418,079) or _missing_\n\n",
    "weibull": "**weibull(** _a_ **,** _b_ **,** _x_ **)** Description: the cumulative Weibull distribution with shape _a_ and scale _b_\n\n**weibull(** _a_ **,** _b_ **,** _x_ **)** = **weibull(** _a_ **,** _b_ **,0,** _x_ **)** , where _a_ is the shape, _b_ is the scale, and _x_ is the value of the Weibull random variable. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: 0 to 1\n\n**weibull(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the cumulative Weibull distribution with shape _a_ , scale _b_ , and location _g_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 1\n\n",
    "weibullden": "**weibullden(** _a_ **,** _b_ **,** _x_ **)** Description: the probability density function of the Weibull distribution with shape _a_ and scale _b_\n\n**weibullden(** _a_ **,** _b_ **,** _x_ **)** = **weibullden(** _a_ **,** _b_ **,0,** _x_ **)** , where _a_ is the shape, _b_ is the scale, and _x_ is the value of the Weibull random variable. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: 0 to 8e+307\n\n**weibullden(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the probability density function of the Weibull distribution with shape _a_ , scale _b_ , and location _g_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 8e+307\n\n",
    "weibullph": "**weibullph(** _a_ **,** _b_ **,** _x_ **)** Description: the cumulative Weibull (proportional hazards) distribution with shape _a_ and scale _b_\n\n**weibullph(** _a_ **,** _b_ **,** _x_ **)** = **weibullph(** _a_ **,** _b_ **,0,** _x_ **)** , where _a_ is the shape, _b_ is the scale, and _x_ is the value of the Weibull random variable. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: 0 to 1\n\n**weibullph(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the cumulative Weibull (proportional hazards) distribution with shape _a_ , scale _b_ , and location _g_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 1\n\n",
    "weibullphden": "**weibullphden(** _a_ **,** _b_ **,** _x_ **)** Description: the probability density function of the Weibull (proportional hazards) distribution with shape _a_ and scale _b_\n\n**weibullphden(** _a_ **,** _b_ **,** _x_ **)** = **weibullphden(** _a_ **,** _b_ **,0,** _x_ **)** , where _a_ is the shape, _b_ is the scale, and _x_ is the value of the Weibull (proportional hazards) random variable. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: 0 to 8e+307\n\n**weibullphden(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the probability density function of the Weibull (proportional hazards) distribution with shape _a_ , scale _b_ , and location _g_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 8e+307\n\n",
    "weibullphtail": "**weibullphtail(** _a_ **,** _b_ **,** _x_ **)** Description: the reverse cumulative Weibull (proportional hazards) distribution with shape _a_ and scale _b_\n\n**weibullphtail(** _a_ **,** _b_ **,** _x_ **)** = **weibullphtail(** _a_ **,** _b_ **,0,** _x_ **)** , where _a_ is the shape, _b_ is the scale, and _x_ is the value of the Weibull (proportional hazards) random variable. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: 0 to 1\n\n**weibullphtail(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the reverse cumulative Weibull (proportional hazards) distribution with shape _a_ , scale _b_ , and location _g_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 1\n\n",
    "weibulltail": "**weibulltail(** _a_ **,** _b_ **,** _x_ **)** Description: the reverse cumulative Weibull distribution with shape _a_ and scale _b_\n\n**weibulltail(** _a_ **,** _b_ **,** _x_ **)** = **weibulltail(** _a_ **,** _b_ **,0,** _x_ **)** , where _a_ is the shape, _b_ is the scale, and _x_ is the value of a Weibull random variable. Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _x_ : 1e-323 to 8e+307 Range: 0 to 1\n\n**weibulltail(** _a_ **,** _b_ **,** _g_ **,** _x_ **)** Description: the reverse cumulative Weibull distribution with shape _a_ , scale _b_ , and location _g_ Domain _a_ : 1e-323 to 8e+307 Domain _b_ : 1e-323 to 8e+307 Domain _g_ : -8e+307 to 8e+307 Domain _x_ : -8e+307 to 8e+307; interesting domain is _x_ _>_ _g_ Range: 0 to 1\n\n",
    "wofd": "**wofd(** _e_d_ **)** Description: the _e_w_ weekly date (weeks since 1960w1) containing date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: **%tw** dates 0100w1 to 9999w52 (integers -96,720 to 418,079)\n\n",
    "word": "**word(** _s_ **,** _n_ **)** Description: the _n_ th word in _s_ ; _missing_ ( **\"\"** ) if _n_ is missing\n\nPositive numbers count words from the beginning of _s_ , and negative numbers count words from the end of _s_. ( **1** is the first word in _s_ , and **-1** is the last word in _s_.) A word is a set of characters that start and terminate with spaces. This is different from a Unicode word, which is a language unit based on either a set of word-boundary rules or dictionaries for several languages (Chinese, Japanese, and Thai). Domain _s_ : strings Domain _n_ : integers Range: strings\n\n**wordcount(** _s_ **)** Description: the number of words in _s_\n\nA word is a set of characters that starts and terminates with spaces, starts with the beginning of the string, or terminates with the end of the string. This is different from a Unicode word, which is a language unit based on either a set of word-boundary rules or dictionaries for several languages (Chinese, Japanese, and Thai). Domain _s_ : strings Range: nonnegative integers 0, 1, 2, ...\n\n",
    "wordbreaklocale": "**wordbreaklocale(** _loc_ **,** _type_ **)** Description: the most closely related locale supported by ICU from _loc_ if _type_ is **1** , the actual locale where the word-boundary analysis data come from if _type_ is **2** ; or an empty string is returned for any other _type_\n\n**wordbreaklocale(\"en_us_texas\", 1)** = **en_US** **wordbreaklocale(\"en_us_texas\", 2)** = **root** Domain _loc_ : strings of locale name Domain _type_ : integers Range: strings\n\n",
    "year": "**year(** _e_d_ **)** Description: the numeric year corresponding to date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: integers 0100 to 9999 (but probably 1800 to 2100)\n\n",
    "yearly": "**yearly(** _s1_ **,** _s2_ [ **,** _Y_ ] **)** Description: the _e_y_ yearly date (year) corresponding to _s1_ based on _s2_ and _Y_ ; _Y_ specifies _topyear_ ; see [**date()**](https://www.stata.com/help.cgi?date\\(\\)) Domain _s1_ : strings Domain _s2_ : strings **\"Y\"** ; **Y** may be prefixed with _##_ Domain _Y_ : integers 1000 to 9998 (but probably 2001 to 2099) Range: **%ty** dates 0100 to 9999 (integers 0100 to 9999) or _missing_\n\n",
    "yh": "**yh(** _Y_ **,** _H_ **)** Description: the _e_h_ half-yearly date (half- years since 1960h1) corresponding to year _Y_ , half-year _H_ Domain _Y_ : integers 1000 to 9999 (but probably 1800 to 2100) Domain _H_ : integers 1, 2 Range: **%th** dates 1000h1 to 9999h2 (integers -1,920 to 16,079)\n\n",
    "ym": "**ym(** _Y_ **,** _M_ **)** Description: the _e_m_ monthly date (months since 1960m1) corresponding to year _Y_ , month _M_ Domain _Y_ : integers 1000 to 9999 (but probably 1800 to 2100) Domain _M_ : integers 1 to 12 Range: **%tm** dates 1000m1 to 9999m12 (integers -11,520 to 96,479)\n\n",
    "yofd": "**yofd(** _e_d_ **)** Description: the _e_y_ yearly date (year) containing date _e_d_ Domain _e_d_ : **%td** dates 01jan0100 to 31dec9999 (integers -679,350 to 2,936,549) Range: **%ty** dates 0100 to 9999 (integers 0100 to 9999)\n\n",
    "yq": "**yq(** _Y_ **,** _Q_ **)** Description: the _e_q_ quarterly date (quarters since 1960q1) corresponding to year _Y_ , quarter _Q_ Domain _Y_ : integers 1000 to 9999 (but probably 1800 to 2100) Domain _Q_ : integers 1 to 4 Range: **%tq** dates 1000q1 to 9999q4 (integers -3,840 to 32,159)\n\n",
    "yw": "**yw(** _Y_ **,** _W_ **)** Description: the _e_w_ weekly date (weeks since 1960w1) corresponding to year _Y_ , week _W_ Domain _Y_ : integers 1000 to 9999 (but probably 1800 to 2100) Domain _W_ : integers 1 to 52 Range: **%tw** dates 1000w1 to 9999w52 (integers -49,920 to 418,079)\n\n"
}